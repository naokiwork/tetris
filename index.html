<!DOCTYPE html>
<html lang="ja">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>TETRIS</title>
    <link rel="stylesheet" href="styles/main.css">
</head>
<body>
    <!-- ã‚¿ã‚¤ãƒˆãƒ«ç”»é¢ -->
    <div id="title-screen" class="title-screen">
        <canvas id="title-canvas"></canvas>
        <div class="title-content">
            <h1 class="title-main">TETRIS</h1>
            <p class="title-subtitle">Press ENTER to Start</p>
        </div>
    </div>
    
    <!-- ã‚²ãƒ¼ãƒ ç”»é¢ -->
    <div id="game-screen" class="game-screen hidden">
        <div class="container">
            <header class="header">
                <h1 class="title">TETRIS</h1>
                <div class="header-controls">
                    <button id="fullscreen-btn" class="header-btn" title="Toggle Fullscreen">â›¶</button>
                    <button id="screenshot-btn" class="header-btn" title="Take Screenshot">ğŸ“·</button>
                </div>
            </header>
            
            <main class="game-container">
                <div class="game-panel">
                    <div class="left-panel">
                        <div class="panel-section hold-section">
                            <h2 class="panel-title">Hold</h2>
                            <canvas id="hold-canvas" width="120" height="120"></canvas>
                        </div>
                        <div class="panel-section controls-section">
                            <h2 class="panel-title">Controls</h2>
                            <div class="controls-list">
                                <div class="control-item">
                                    <span class="control-key"><span style="font-size: 1em;">â†</span> <span style="font-size: 1em;">â†’</span></span>
                                    <span class="control-desc">Move Left/Right</span>
                                </div>
                                <div class="control-item">
                                    <span class="control-key">â†“</span>
                                    <span class="control-desc">Soft Drop</span>
                                </div>
                                <div class="control-item">
                                    <span class="control-key">Z</span>
                                    <span class="control-desc">Rotate Left</span>
                                </div>
                                <div class="control-item">
                                    <span class="control-key">X</span>
                                    <span class="control-desc">Rotate Right</span>
                                </div>
                                <div class="control-item">
                                    <span class="control-key">C</span>
                                    <span class="control-desc">Hold</span>
                                </div>
                                <div class="control-item">
                                    <span class="control-key">Space</span>
                                    <span class="control-desc">Hard Drop</span>
                                </div>
                            </div>
                        </div>
                    </div>
                    <div class="panel-section board-section">
                        <div class="score-panel">
                            <div class="score-item">
                                <span class="score-label">Score</span>
                                <span id="score-value" class="score-value">0</span>
                            </div>
                            <div class="score-item">
                                <span class="score-label">Level</span>
                                <span id="level-value" class="score-value">1</span>
                            </div>
                        <div class="score-item">
                            <span class="score-label">Lines</span>
                            <span id="lines-value" class="score-value">0</span>
                        </div>
                    </div>
                    <div class="stats-panel" id="stats-panel" style="display: none;">
                        <h3 class="stats-title">Statistics</h3>
                        <div class="stats-item">
                            <span class="stats-label">Total Games:</span>
                            <span id="stats-total-games" class="stats-value">0</span>
                        </div>
                        <div class="stats-item">
                            <span class="stats-label">Total Play Time:</span>
                            <span id="stats-total-time" class="stats-value">0s</span>
                        </div>
                        <div class="stats-item">
                            <span class="stats-label">Average Score:</span>
                            <span id="stats-avg-score" class="stats-value">0</span>
                        </div>
                        <div class="stats-item">
                            <span class="stats-label">Max Level:</span>
                            <span id="stats-max-level" class="stats-value">1</span>
                        </div>
                        <div class="stats-item">
                            <span class="stats-label">Max Lines:</span>
                            <span id="stats-max-lines" class="stats-value">0</span>
                        </div>
                        <button id="close-stats" class="close-stats-btn">Close</button>
                        <button id="show-history-btn" class="show-history-btn">Show History</button>
                        <button id="export-stats-btn" class="export-stats-btn">Export Stats</button>
                        <input type="file" id="import-stats-input" accept=".json" style="display: none;">
                        <button id="import-stats-btn" class="import-stats-btn">Import Stats</button>
                    </div>
                    <div class="history-panel" id="history-panel" style="display: none;">
                        <h3 class="history-title">Game History</h3>
                        <div id="history-list" class="history-list"></div>
                        <button id="close-history" class="close-history-btn">Close</button>
                    </div>
                    <button id="show-stats-btn" class="show-stats-btn">Show Stats</button>
                        <div class="game-controls">
                            <label for="speed-control" class="speed-label">Game Speed:</label>
                            <input type="range" id="speed-control" min="1" max="10" value="1" class="speed-slider">
                            <span id="speed-value" class="speed-value">1</span>
                        </div>
                    <canvas id="game-canvas" width="400" height="800"></canvas>
                </div>
                    <div class="panel-section next-section">
                        <h2 class="panel-title">Next</h2>
                        <canvas id="next-canvas" width="120" height="600"></canvas>
                    </div>
                </div>
            </main>
        </div>
    </div>
    
    <script>
        // ã‚¿ã‚¤ãƒˆãƒ«ç”»é¢ã¨ã‚²ãƒ¼ãƒ ç”»é¢ã®è¦ç´ ã‚’å–å¾—
        const titleScreen = document.getElementById('title-screen');
        const gameScreen = document.getElementById('game-screen');
        let gameStarted = false;
        
        // ã‚¿ã‚¤ãƒˆãƒ«ç”»é¢ã®ã‚¢ãƒ‹ãƒ¡ãƒ¼ã‚·ãƒ§ãƒ³
        function initTitleAnimation() {
            const titleCanvas = document.getElementById('title-canvas');
            titleCanvas.width = window.innerWidth;
            titleCanvas.height = window.innerHeight;
            const titleCtx = titleCanvas.getContext('2d');
            
            // ãƒ†ãƒˆãƒªãƒŸãƒã®ç¨®é¡ã¨è‰²ï¼ˆã‚²ãƒ¼ãƒ ã¨åŒã˜ï¼‰
            const PIECE_TYPES = ['I', 'O', 'T', 'S', 'Z', 'J', 'L'];
            const PIECE_COLORS = {
                'I': '#00FFFF',  // ã‚·ã‚¢ãƒ³ï¼ˆå…¬å¼æ¨™æº–è‰²ï¼‰
                'O': '#FFFF00',  // é»„è‰²ï¼ˆå…¬å¼æ¨™æº–è‰²ï¼‰
                'T': '#FF00FF',  // ç´«ï¼ˆãƒã‚¼ãƒ³ã‚¿ã€å…¬å¼æ¨™æº–è‰²ï¼‰
                'S': '#00FF00',  // ç·‘ï¼ˆå…¬å¼æ¨™æº–è‰²ï¼‰
                'Z': '#FF0000',  // èµ¤ï¼ˆå…¬å¼æ¨™æº–è‰²ï¼‰
                'J': '#FFA500',  // ã‚ªãƒ¬ãƒ³ã‚¸ï¼ˆå…¬å¼æ¨™æº–è‰²ï¼‰- Jã¯ã‚ªãƒ¬ãƒ³ã‚¸
                'L': '#0000FF'   // é’ï¼ˆå…¬å¼æ¨™æº–è‰²ï¼‰- Lã¯é’
            };
            const PIECE_SHAPES = {
                'I': [{x: -1, y: 0}, {x: 0, y: 0}, {x: 1, y: 0}, {x: 2, y: 0}],
                'O': [{x: 0, y: 0}, {x: 1, y: 0}, {x: 0, y: 1}, {x: 1, y: 1}],
                'T': [{x: -1, y: 0}, {x: 0, y: 0}, {x: 1, y: 0}, {x: 0, y: 1}],
                'S': [{x: -1, y: 1}, {x: 0, y: 1}, {x: 0, y: 0}, {x: 1, y: 0}],
                'Z': [{x: -1, y: 0}, {x: 0, y: 0}, {x: 0, y: 1}, {x: 1, y: 1}],
                'J': [{x: -1, y: 0}, {x: 0, y: 0}, {x: 1, y: 0}, {x: -1, y: 1}],
                'L': [{x: -1, y: 0}, {x: 0, y: 0}, {x: 1, y: 0}, {x: 1, y: 1}]
            };
            
            const CELL_SIZE = 30;
            const blocks = [];
            let lastSpawnTime = 0;
            const SPAWN_INTERVAL = 250; // æ–°ã—ã„ãƒ–ãƒ­ãƒƒã‚¯ã‚’ç”Ÿæˆã™ã‚‹é–“éš”ï¼ˆãƒŸãƒªç§’ï¼‰- 3å€ã®é »åº¦
            
            // åˆæœŸãƒ–ãƒ­ãƒƒã‚¯ã‚’ç”Ÿæˆ
            function createBlock() {
                const type = PIECE_TYPES[Math.floor(Math.random() * PIECE_TYPES.length)];
                const shape = PIECE_SHAPES[type];
                const minX = Math.min(...shape.map(p => p.x));
                const maxX = Math.max(...shape.map(p => p.x));
                const width = maxX - minX + 1;
                const maxWidth = Math.max(1, titleCanvas.width / CELL_SIZE - width);
                const startX = Math.random() * maxWidth + width / 2;
                
                return {
                    type: type,
                    x: startX,
                    y: -Math.max(...shape.map(p => p.y)) - 1,
                    shape: shape,
                    speed: 0.3 + Math.random() * 0.5,
                    rotation: Math.random() * Math.PI * 2,
                    rotationSpeed: (Math.random() - 0.5) * 0.02
                };
            }
            
            // åˆæœŸãƒ–ãƒ­ãƒƒã‚¯ã‚’ç”Ÿæˆï¼ˆç”»é¢å…¨ä½“ã«åˆ†æ•£ï¼‰
            for (let i = 0; i < 30; i++) {
                const block = createBlock();
                block.y = -Math.random() * titleCanvas.height * 2 - 50; // ç”»é¢å¤–ã®ãƒ©ãƒ³ãƒ€ãƒ ãªä½ç½®
                blocks.push(block);
            }
            
            // ãƒ–ãƒ­ãƒƒã‚¯ã‚’æç”»
            function drawBlock(block) {
                titleCtx.save();
                titleCtx.translate(block.x * CELL_SIZE, block.y * CELL_SIZE);
                titleCtx.rotate(block.rotation);
                
                const color = PIECE_COLORS[block.type];
                block.shape.forEach(cell => {
                    const x = cell.x * CELL_SIZE;
                    const y = cell.y * CELL_SIZE;
                    
                    // ã‚°ãƒ©ãƒ‡ãƒ¼ã‚·ãƒ§ãƒ³åŠ¹æœ
                    const gradient = titleCtx.createRadialGradient(x + CELL_SIZE/2, y + CELL_SIZE/2, 0, x + CELL_SIZE/2, y + CELL_SIZE/2, CELL_SIZE);
                    gradient.addColorStop(0, color);
                    gradient.addColorStop(1, color + '80');
                    
                    titleCtx.fillStyle = gradient;
                    titleCtx.fillRect(x + 2, y + 2, CELL_SIZE - 4, CELL_SIZE - 4);
                    
                    // å…‰æ²¢åŠ¹æœ
                    titleCtx.strokeStyle = 'rgba(255, 255, 255, 0.3)';
                    titleCtx.lineWidth = 2;
                    titleCtx.strokeRect(x + 2, y + 2, CELL_SIZE - 4, CELL_SIZE - 4);
                });
                
                titleCtx.restore();
            }
            
            // ã‚¢ãƒ‹ãƒ¡ãƒ¼ã‚·ãƒ§ãƒ³ãƒ«ãƒ¼ãƒ—
            function animate(currentTime) {
                if (titleScreen.classList.contains('hidden')) {
                    return; // ã‚¿ã‚¤ãƒˆãƒ«ç”»é¢ãŒéè¡¨ç¤ºã®å ´åˆã¯åœæ­¢
                }
                
                // èƒŒæ™¯ã‚’ã‚¯ãƒªã‚¢ï¼ˆåŠé€æ˜ã«ã—ã¦æ®‹åƒåŠ¹æœï¼‰
                titleCtx.fillStyle = 'rgba(13, 17, 23, 0.15)';
                titleCtx.fillRect(0, 0, titleCanvas.width, titleCanvas.height);
                
                // å®šæœŸçš„ã«æ–°ã—ã„ãƒ–ãƒ­ãƒƒã‚¯ã‚’ç”Ÿæˆï¼ˆè¤‡æ•°åŒæ™‚ã«ç”Ÿæˆï¼‰
                if (currentTime - lastSpawnTime > SPAWN_INTERVAL) {
                    // ä¸€åº¦ã«2ã€œ3å€‹ã®ãƒ–ãƒ­ãƒƒã‚¯ã‚’ç”Ÿæˆ
                    const spawnCount = Math.floor(Math.random() * 2) + 2; // 2å€‹ã¾ãŸã¯3å€‹
                    for (let i = 0; i < spawnCount; i++) {
                        const newBlock = createBlock();
                        newBlock.y = -Math.max(...newBlock.shape.map(p => p.y)) * CELL_SIZE - 20 - i * 30;
                        blocks.push(newBlock);
                    }
                    lastSpawnTime = currentTime;
                }
                
                // ãƒ–ãƒ­ãƒƒã‚¯ã‚’æ›´æ–°ãƒ»æç”»
                for (let i = blocks.length - 1; i >= 0; i--) {
                    const block = blocks[i];
                    block.y += block.speed;
                    block.rotation += block.rotationSpeed;
                    
                    // ç”»é¢ä¸‹éƒ¨ã«åˆ°é”ã—ãŸã‚‰å‰Šé™¤ï¼ˆæ–°ã—ã„ãƒ–ãƒ­ãƒƒã‚¯ãŒç”Ÿæˆã•ã‚Œã‚‹ï¼‰
                    const maxY = Math.max(...block.shape.map(p => p.y));
                    if (block.y + maxY * CELL_SIZE > titleCanvas.height + 100) {
                        blocks.splice(i, 1);
                        continue;
                    }
                    
                    drawBlock(block);
                }
                
                requestAnimationFrame(animate);
            }
            
            // ãƒªã‚µã‚¤ã‚ºæ™‚ã®å‡¦ç†
            window.addEventListener('resize', () => {
                titleCanvas.width = window.innerWidth;
                titleCanvas.height = window.innerHeight;
            });
            
            animate(performance.now());
        }
        
        // ã‚¿ã‚¤ãƒˆãƒ«ç”»é¢ã®ã‚¢ãƒ‹ãƒ¡ãƒ¼ã‚·ãƒ§ãƒ³ã‚’åˆæœŸåŒ–
        initTitleAnimation();
        
        // Enterã‚­ãƒ¼ã§ã‚²ãƒ¼ãƒ é–‹å§‹
        document.addEventListener('keydown', (e) => {
            if (e.key === 'Enter' && !gameStarted) {
                console.log('Enter key pressed - starting game');
                titleScreen.classList.add('hidden');
                gameScreen.classList.remove('hidden');
                gameStarted = true;
                startGame();
            }
        });
        
        // ã‚²ãƒ¼ãƒ é–‹å§‹
        function startGame() {
            const canvas = document.getElementById('game-canvas');
            const ctx = canvas.getContext('2d');
            const nextCanvas = document.getElementById('next-canvas');
            const nextCtx = nextCanvas.getContext('2d');
            const holdCanvas = document.getElementById('hold-canvas');
            const holdCtx = holdCanvas.getContext('2d');
            
            const CELL_SIZE = 40;
            const NEXT_CELL_SIZE = 20; // Nextãƒ–ãƒ­ãƒƒã‚¯è¡¨ç¤ºç”¨ã®ã‚»ãƒ«ã‚µã‚¤ã‚º
            const HOLD_CELL_SIZE = 25; // Holdãƒ–ãƒ­ãƒƒã‚¯è¡¨ç¤ºç”¨ã®ã‚»ãƒ«ã‚µã‚¤ã‚º
            const BOARD_WIDTH = 10;
            const BOARD_HEIGHT = 20;
            const BG_COLOR = '#2d3136'; // èƒŒæ™¯è‰²
            const DROP_INTERVAL = 500; // è½ä¸‹é–“éš”ï¼ˆãƒŸãƒªç§’ï¼‰
            
            // ãƒ†ãƒˆãƒªãƒŸãƒã®ç¨®é¡ã¨è‰²
            const PIECE_TYPES = ['I', 'O', 'T', 'S', 'Z', 'J', 'L'];
            const PIECE_COLORS = {
                'I': '#00FFFF',  // ã‚·ã‚¢ãƒ³ï¼ˆå…¬å¼æ¨™æº–è‰²ï¼‰
                'O': '#FFFF00',  // é»„è‰²ï¼ˆå…¬å¼æ¨™æº–è‰²ï¼‰
                'T': '#FF00FF',  // ç´«ï¼ˆãƒã‚¼ãƒ³ã‚¿ã€å…¬å¼æ¨™æº–è‰²ï¼‰
                'S': '#00FF00',  // ç·‘ï¼ˆå…¬å¼æ¨™æº–è‰²ï¼‰
                'Z': '#FF0000',  // èµ¤ï¼ˆå…¬å¼æ¨™æº–è‰²ï¼‰
                'J': '#FFA500',  // ã‚ªãƒ¬ãƒ³ã‚¸ï¼ˆå…¬å¼æ¨™æº–è‰²ï¼‰- Jã¯ã‚ªãƒ¬ãƒ³ã‚¸
                'L': '#0000FF'   // é’ï¼ˆå…¬å¼æ¨™æº–è‰²ï¼‰- Lã¯é’
            };
            
            // ãƒ†ãƒˆãƒªãƒŸãƒã®å½¢çŠ¶ï¼ˆç›¸å¯¾åº§æ¨™ã€ä¸­å¿ƒã‚’(0,0)ã¨ã—ãŸç›¸å¯¾ä½ç½®ï¼‰
            const PIECE_SHAPES = {
                'I': [{x: -1, y: 0}, {x: 0, y: 0}, {x: 1, y: 0}, {x: 2, y: 0}],
                'O': [{x: 0, y: 0}, {x: 1, y: 0}, {x: 0, y: 1}, {x: 1, y: 1}],
                'T': [{x: -1, y: 0}, {x: 0, y: 0}, {x: 1, y: 0}, {x: 0, y: 1}],
                'S': [{x: -1, y: 1}, {x: 0, y: 1}, {x: 0, y: 0}, {x: 1, y: 0}],
                'Z': [{x: -1, y: 0}, {x: 0, y: 0}, {x: 0, y: 1}, {x: 1, y: 1}],
                'J': [{x: -1, y: 0}, {x: 0, y: 0}, {x: 1, y: 0}, {x: -1, y: 1}],
                'L': [{x: -1, y: 0}, {x: 0, y: 0}, {x: 1, y: 0}, {x: 1, y: 1}]
            };
            
            console.log('Canvas initialized');
            console.log('Canvas size:', canvas.width, 'x', canvas.height);
            
            // ã‚²ãƒ¼ãƒ çŠ¶æ…‹
            let currentBlock = null; // ç¾åœ¨ã®ãƒ–ãƒ­ãƒƒã‚¯ {type, x, y, shape}
            let placedBlocks = []; // è½ä¸‹ã—ãŸãƒ–ãƒ­ãƒƒã‚¯ã®é…åˆ— [{type, x, y, shape}, ...]
            let nextBlocks = []; // æ¬¡ã®5ã¤ã®ãƒ–ãƒ­ãƒƒã‚¯ [{type, shape}, ...]
            let holdBlock = null; // ãƒ›ãƒ¼ãƒ«ãƒ‰ä¸­ã®ãƒ–ãƒ­ãƒƒã‚¯ {type, shape}
            let canHold = true; // ãƒ›ãƒ¼ãƒ«ãƒ‰å¯èƒ½ã‹ã©ã†ã‹ï¼ˆ1å›ã®ãƒ”ãƒ¼ã‚¹ã«ã¤ã1å›ã®ã¿ï¼‰
            let dropTimer = 0;
            let lastTime = performance.now();
            let gameActive = false;
            let gameOver = false; // ã‚²ãƒ¼ãƒ ã‚ªãƒ¼ãƒãƒ¼çŠ¶æ…‹
            let showRetryMessage = false; // ãƒªãƒˆãƒ©ã‚¤ãƒ¡ãƒƒã‚»ãƒ¼ã‚¸ã‚’è¡¨ç¤ºã™ã‚‹ã‹
            window.currentDropInterval = DROP_INTERVAL_BASE; // ç¾åœ¨ã®è½ä¸‹é–“éš”
            
            // ã‚¹ã‚³ã‚¢ã€ãƒ¬ãƒ™ãƒ«ã€ãƒ©ã‚¤ãƒ³æ•°
            let score = 0;
            let level = 1;
            let lines = 0;
            let combo = 0; // ã‚³ãƒ³ãƒœæ•°
            let lastClearTime = 0; // æœ€å¾Œã«ãƒ©ã‚¤ãƒ³ã‚’æ¶ˆå»ã—ãŸæ™‚åˆ»
            let softDropScore = 0; // ã‚½ãƒ•ãƒˆãƒ‰ãƒ­ãƒƒãƒ—ã‚¹ã‚³ã‚¢
            const DROP_INTERVAL_BASE = 500; // åŸºæœ¬è½ä¸‹é–“éš”ï¼ˆãƒŸãƒªç§’ï¼‰
            const COMBO_TIMEOUT = 2000; // ã‚³ãƒ³ãƒœã‚¿ã‚¤ãƒ ã‚¢ã‚¦ãƒˆï¼ˆãƒŸãƒªç§’ï¼‰
            
            // ãƒã‚¤ã‚¹ã‚³ã‚¢ã®èª­ã¿è¾¼ã¿
            let highScore = parseInt(localStorage.getItem('tetrisHighScore') || '0', 10);
            
            // ã‚¹ã‚³ã‚¢ãƒ»ãƒ¬ãƒ™ãƒ«ãƒ»ãƒ©ã‚¤ãƒ³æ•°ã®è¡¨ç¤ºã‚’æ›´æ–°
            function updateScoreDisplay() {
                const scoreElement = document.getElementById('score-value');
                const levelElement = document.getElementById('level-value');
                const linesElement = document.getElementById('lines-value');
                
                if (scoreElement) {
                    const oldScore = parseInt(scoreElement.textContent.replace(/,/g, '') || '0', 10);
                    const newScore = score;
                    scoreElement.textContent = newScore.toLocaleString();
                    
                    // ã‚¹ã‚³ã‚¢ãŒå¢—åŠ ã—ãŸæ™‚ã«ã‚¢ãƒ‹ãƒ¡ãƒ¼ã‚·ãƒ§ãƒ³åŠ¹æœ
                    if (newScore > oldScore) {
                        scoreElement.style.transform = 'scale(1.2)';
                        scoreElement.style.color = '#4caf50';
                        setTimeout(() => {
                            scoreElement.style.transform = 'scale(1)';
                            scoreElement.style.color = '';
                        }, 300);
                    }
                }
                
                if (levelElement) {
                    const oldLevel = parseInt(levelElement.textContent || '1', 10);
                    const newLevel = level;
                    levelElement.textContent = newLevel;
                    
                    // ãƒ¬ãƒ™ãƒ«ãŒä¸ŠãŒã£ãŸæ™‚ã«ã‚¢ãƒ‹ãƒ¡ãƒ¼ã‚·ãƒ§ãƒ³åŠ¹æœ
                    if (newLevel > oldLevel) {
                        levelElement.style.transform = 'scale(1.3)';
                        levelElement.style.color = '#ff9800';
                        setTimeout(() => {
                            levelElement.style.transform = 'scale(1)';
                            levelElement.style.color = '';
                        }, 500);
                    }
                }
                
                if (linesElement) {
                    linesElement.textContent = lines;
                }
                
                // ãƒã‚¤ã‚¹ã‚³ã‚¢ã®æ›´æ–°
                if (score > highScore) {
                    highScore = score;
                    localStorage.setItem('tetrisHighScore', highScore.toString());
                    updateHighScoreDisplay();
                }
            }
            
            // ãƒã‚¤ã‚¹ã‚³ã‚¢è¡¨ç¤ºã®æ›´æ–°
            function updateHighScoreDisplay() {
                let highScoreElement = document.getElementById('high-score-value');
                if (!highScoreElement) {
                    // ãƒã‚¤ã‚¹ã‚³ã‚¢è¡¨ç¤ºã‚’è¿½åŠ 
                    const scorePanel = document.querySelector('.score-panel');
                    if (scorePanel) {
                        const highScoreItem = document.createElement('div');
                        highScoreItem.className = 'score-item';
                        highScoreItem.innerHTML = `
                            <span class="score-label">High Score</span>
                            <span id="high-score-value" class="score-value">${highScore.toLocaleString()}</span>
                        `;
                        scorePanel.appendChild(highScoreItem);
                        highScoreElement = document.getElementById('high-score-value');
                    }
                }
                if (highScoreElement) {
                    highScoreElement.textContent = highScore.toLocaleString();
                }
            }
            
            // çµ±è¨ˆãƒ‡ãƒ¼ã‚¿ã®è¡¨ç¤ºã‚’æ›´æ–°
            function updateStatsDisplay() {
                document.getElementById('stats-total-games').textContent = gameStats.totalGames;
                document.getElementById('stats-total-time').textContent = formatTime(gameStats.totalPlayTime);
                document.getElementById('stats-avg-score').textContent = gameStats.totalGames > 0 
                    ? Math.floor(gameStats.totalScore / gameStats.totalGames).toLocaleString() 
                    : '0';
                document.getElementById('stats-max-level').textContent = gameStats.maxLevel;
                document.getElementById('stats-max-lines').textContent = gameStats.maxLines;
            }
            
            // ã‚²ãƒ¼ãƒ å±¥æ­´ã®è¡¨ç¤º
            function showGameHistory() {
                const historyPanel = document.getElementById('history-panel');
                const historyList = document.getElementById('history-list');
                const statsPanel = document.getElementById('stats-panel');
                const showStatsBtn = document.getElementById('show-stats-btn');
                
                if (historyPanel && historyList) {
                    const gameHistory = JSON.parse(localStorage.getItem('tetrisGameHistory') || '[]');
                    historyList.innerHTML = '';
                    
                    if (gameHistory.length === 0) {
                        historyList.innerHTML = '<p style="text-align: center; color: var(--color-text-secondary);">No game history yet.</p>';
                    } else {
                        gameHistory.slice().reverse().forEach((game, index) => {
                            const historyItem = document.createElement('div');
                            historyItem.className = 'history-item';
                            const date = new Date(game.date);
                            historyItem.innerHTML = `
                                <div class="history-date">${date.toLocaleString()}</div>
                                <div class="history-stats">
                                    <span>Score: ${game.score.toLocaleString()}</span>
                                    <span>Level: ${game.level}</span>
                                    <span>Lines: ${game.lines}</span>
                                    <span>Time: ${formatTime(game.playTime)}</span>
                                </div>
                            `;
                            historyList.appendChild(historyItem);
                        });
                    }
                    
                    historyPanel.style.display = 'block';
                    if (statsPanel) statsPanel.style.display = 'none';
                    if (showStatsBtn) showStatsBtn.style.display = 'block';
                }
            }
            
            // çµ±è¨ˆãƒ‡ãƒ¼ã‚¿ã®ã‚¨ã‚¯ã‚¹ãƒãƒ¼ãƒˆ
            function exportStats() {
                const data = {
                    stats: gameStats,
                    highScore: highScore,
                    history: JSON.parse(localStorage.getItem('tetrisGameHistory') || '[]'),
                    exportDate: new Date().toISOString()
                };
                const blob = new Blob([JSON.stringify(data, null, 2)], { type: 'application/json' });
                const url = URL.createObjectURL(blob);
                const a = document.createElement('a');
                a.href = url;
                a.download = `tetris-stats-${Date.now()}.json`;
                a.click();
                URL.revokeObjectURL(url);
            }
            
            // çµ±è¨ˆãƒ‡ãƒ¼ã‚¿ã®ã‚¤ãƒ³ãƒãƒ¼ãƒˆ
            function importStats(file) {
                const reader = new FileReader();
                reader.onload = (e) => {
                    try {
                        const data = JSON.parse(e.target.result);
                        if (data.stats) {
                            gameStats = data.stats;
                            localStorage.setItem('tetrisTotalPlayTime', gameStats.totalPlayTime.toString());
                            localStorage.setItem('tetrisTotalScore', gameStats.totalScore.toString());
                            localStorage.setItem('tetrisTotalGames', gameStats.totalGames.toString());
                            localStorage.setItem('tetrisMaxLevel', gameStats.maxLevel.toString());
                            localStorage.setItem('tetrisMaxLines', gameStats.maxLines.toString());
                        }
                        if (data.highScore !== undefined) {
                            highScore = data.highScore;
                            localStorage.setItem('tetrisHighScore', highScore.toString());
                        }
                        if (data.history) {
                            localStorage.setItem('tetrisGameHistory', JSON.stringify(data.history));
                        }
                        updateStatsDisplay();
                        updateHighScoreDisplay();
                        alert('Stats imported successfully!');
                    } catch (err) {
                        alert('Failed to import stats: ' + err.message);
                    }
                };
                reader.readAsText(file);
            }
            
            // æ™‚é–“ã‚’ãƒ•ã‚©ãƒ¼ãƒãƒƒãƒˆ
            function formatTime(seconds) {
                const hours = Math.floor(seconds / 3600);
                const minutes = Math.floor((seconds % 3600) / 60);
                const secs = seconds % 60;
                if (hours > 0) {
                    return `${hours}h ${minutes}m ${secs}s`;
                } else if (minutes > 0) {
                    return `${minutes}m ${secs}s`;
                } else {
                    return `${secs}s`;
                }
            }
            
            // çµ±è¨ˆãƒ‘ãƒãƒ«ã®è¡¨ç¤º/éè¡¨ç¤º
            document.addEventListener('DOMContentLoaded', () => {
                const showStatsBtn = document.getElementById('show-stats-btn');
                const statsPanel = document.getElementById('stats-panel');
                const closeStatsBtn = document.getElementById('close-stats');
                
                if (showStatsBtn && statsPanel) {
                    showStatsBtn.addEventListener('click', () => {
                        updateStatsDisplay();
                        statsPanel.style.display = 'block';
                        showStatsBtn.style.display = 'none';
                    });
                }
                
                if (closeStatsBtn && statsPanel && showStatsBtn) {
                    closeStatsBtn.addEventListener('click', () => {
                        statsPanel.style.display = 'none';
                        showStatsBtn.style.display = 'block';
                    });
                }
                
                // ã‚²ãƒ¼ãƒ å±¥æ­´ã®è¡¨ç¤º
                const showHistoryBtn = document.getElementById('show-history-btn');
                const historyPanel = document.getElementById('history-panel');
                const closeHistoryBtn = document.getElementById('close-history');
                if (showHistoryBtn && historyPanel) {
                    showHistoryBtn.addEventListener('click', () => {
                        showGameHistory();
                    });
                }
                if (closeHistoryBtn && historyPanel && showStatsBtn) {
                    closeHistoryBtn.addEventListener('click', () => {
                        historyPanel.style.display = 'none';
                        showStatsBtn.style.display = 'block';
                    });
                }
                
                // çµ±è¨ˆãƒ‡ãƒ¼ã‚¿ã®ã‚¨ã‚¯ã‚¹ãƒãƒ¼ãƒˆ/ã‚¤ãƒ³ãƒãƒ¼ãƒˆ
                const exportStatsBtn = document.getElementById('export-stats-btn');
                const importStatsBtn = document.getElementById('import-stats-btn');
                const importStatsInput = document.getElementById('import-stats-input');
                
                if (exportStatsBtn) {
                    exportStatsBtn.addEventListener('click', exportStats);
                }
                if (importStatsBtn && importStatsInput) {
                    importStatsBtn.addEventListener('click', () => {
                        importStatsInput.click();
                    });
                    importStatsInput.addEventListener('change', (e) => {
                        if (e.target.files.length > 0) {
                            importStats(e.target.files[0]);
                        }
                    });
                }
                
                // ãƒ•ãƒ«ã‚¹ã‚¯ãƒªãƒ¼ãƒ³ãƒ¢ãƒ¼ãƒ‰
                const fullscreenBtn = document.getElementById('fullscreen-btn');
                if (fullscreenBtn) {
                    fullscreenBtn.addEventListener('click', () => {
                        if (!document.fullscreenElement) {
                            document.documentElement.requestFullscreen().catch(err => {
                                console.log('Fullscreen error:', err);
                            });
                            fullscreenBtn.textContent = 'â›¶';
                        } else {
                            document.exitFullscreen();
                            fullscreenBtn.textContent = 'â›¶';
                        }
                    });
                }
                
                // ã‚¹ã‚¯ãƒªãƒ¼ãƒ³ã‚·ãƒ§ãƒƒãƒˆæ©Ÿèƒ½
                const screenshotBtn = document.getElementById('screenshot-btn');
                if (screenshotBtn) {
                    screenshotBtn.addEventListener('click', () => {
                        const canvas = document.getElementById('game-canvas');
                        canvas.toBlob((blob) => {
                            const url = URL.createObjectURL(blob);
                            const a = document.createElement('a');
                            a.href = url;
                            a.download = `tetris-${Date.now()}.png`;
                            a.click();
                            URL.revokeObjectURL(url);
                        });
                    });
                }
                
                // ã‚²ãƒ¼ãƒ é€Ÿåº¦ã®æ‰‹å‹•èª¿æ•´
                const speedControl = document.getElementById('speed-control');
                const speedValue = document.getElementById('speed-value');
                if (speedControl && speedValue) {
                    speedControl.value = manualSpeedLevel;
                    speedValue.textContent = manualSpeedLevel;
                    speedControl.addEventListener('input', (e) => {
                        updateManualSpeed(parseInt(e.target.value, 10));
                    });
                }
            });
            
            // ã‚¹ã‚³ã‚¢è¨ˆç®—ï¼ˆãƒ©ã‚¤ãƒ³æ¶ˆå»æ™‚ï¼‰
            function calculateScore(linesCleared) {
                // ãƒ†ãƒˆãƒªã‚¹ã®æ¨™æº–ã‚¹ã‚³ã‚¢è¨ˆç®—
                // 1è¡Œ: 100 * level
                // 2è¡Œ: 300 * level
                // 3è¡Œ: 500 * level
                // 4è¡Œï¼ˆTetrisï¼‰: 800 * level
                const baseScores = [0, 100, 300, 500, 800];
                const baseScore = baseScores[linesCleared] || 0;
                
                // ã‚³ãƒ³ãƒœãƒœãƒ¼ãƒŠã‚¹ï¼ˆé€£ç¶šã§ãƒ©ã‚¤ãƒ³ã‚’æ¶ˆå»ã—ãŸå ´åˆï¼‰
                let comboBonus = 0;
                if (combo > 0) {
                    comboBonus = combo * 50 * level;
                }
                
                return (baseScore * level) + comboBonus;
            }
            
            // ãƒ¬ãƒ™ãƒ«è¨ˆç®—ï¼ˆãƒ©ã‚¤ãƒ³æ•°ã«åŸºã¥ãï¼‰
            function updateLevel() {
                const newLevel = Math.floor(lines / 10) + 1;
                if (newLevel !== level) {
                    level = newLevel;
                    // ãƒ¬ãƒ™ãƒ«ãŒä¸ŠãŒã‚‹ã¨è½ä¸‹é€Ÿåº¦ãŒé€Ÿããªã‚‹
                    // ãƒ¬ãƒ™ãƒ«1: 500ms, ãƒ¬ãƒ™ãƒ«2: 450ms, ... ãƒ¬ãƒ™ãƒ«10: 50ms
                    const newDropInterval = Math.max(50, DROP_INTERVAL_BASE - (level - 1) * 50);
                    // ã‚°ãƒ­ãƒ¼ãƒãƒ«å¤‰æ•°ã¨ã—ã¦ä¿æŒï¼ˆupdateé–¢æ•°ã§ä½¿ç”¨ï¼‰
                    window.currentDropInterval = newDropInterval;
                }
            }
            let showGrid = true; // ã‚°ãƒªãƒƒãƒ‰è¡¨ç¤ºãƒ•ãƒ©ã‚°
            
            // ã‚«ã‚¦ãƒ³ãƒˆãƒ€ã‚¦ãƒ³è¡¨ç¤º
            let countdown = 3;
            
            // ã‚«ã‚¦ãƒ³ãƒˆãƒ€ã‚¦ãƒ³è¦ç´ ã‚’ä½œæˆï¼ˆCanvasã®ä¸­å¿ƒã«é…ç½®ï¼‰
            const countdownElement = document.createElement('div');
            countdownElement.id = 'countdown';
            // Canvasã®ä½ç½®ã‚’å–å¾—ã—ã¦ä¸­å¤®ã«é…ç½®
            const canvasRect = canvas.getBoundingClientRect();
            const canvasCenterX = canvasRect.left + canvasRect.width / 2;
            const canvasCenterY = canvasRect.top + canvasRect.height / 2;
            countdownElement.style.cssText = `position:fixed;top:${canvasCenterY}px;left:${canvasCenterX}px;transform:translate(-50%,-50%);font-size:120px;font-weight:bold;color:#0969da;z-index:10001;pointer-events:none;text-shadow:0 0 20px #0969da, 0 0 40px #0969da, 2px 2px 4px rgba(0,0,0,0.5);animation:countdownPulse 0.5s ease-out;`;
            document.body.appendChild(countdownElement);
            
            // ã‚«ã‚¦ãƒ³ãƒˆãƒ€ã‚¦ãƒ³å‡¦ç†ï¼ˆ2å€é€Ÿï¼‰
            function showCountdown() {
                // ã‚«ã‚¦ãƒ³ãƒˆãƒ€ã‚¦ãƒ³ä¸­ã‚‚èƒŒæ™¯ã¨ã‚°ãƒªãƒƒãƒ‰ã‚’æç”»
                drawBackground();
                
                // ã‚²ãƒ¼ãƒ ã‚ªãƒ¼ãƒãƒ¼ã‚ªãƒ¼ãƒãƒ¼ãƒ¬ã‚¤ãŒæ®‹ã£ã¦ã„ãªã„ã‹ç¢ºèªã—ã¦å‰Šé™¤
                const gameOverElement = document.getElementById('game-over-overlay');
                if (gameOverElement) {
                    gameOverElement.remove();
                }
                
                if (countdown > 0) {
                    countdownElement.textContent = countdown.toString();
                    countdown--;
                    setTimeout(showCountdown, 500); // 1ç§’ã‹ã‚‰0.5ç§’ã«å¤‰æ›´ï¼ˆ2å€é€Ÿï¼‰
                } else {
                    countdownElement.textContent = 'START!';
                    setTimeout(() => {
                        countdownElement.remove();
                        // å¿µã®ãŸã‚ã‚²ãƒ¼ãƒ ã‚ªãƒ¼ãƒãƒ¼ã‚ªãƒ¼ãƒãƒ¼ãƒ¬ã‚¤ã‚’å†åº¦ç¢ºèªã—ã¦å‰Šé™¤
                        const gameOverElement2 = document.getElementById('game-over-overlay');
                        if (gameOverElement2) {
                            gameOverElement2.remove();
                        }
                        gameActive = true;
                        // æ¬¡ã®ãƒ–ãƒ­ãƒƒã‚¯ã‚’æº–å‚™
                        prepareNextBlocks();
                        // æœ€åˆã®ãƒ–ãƒ­ãƒƒã‚¯ã‚’ç”Ÿæˆ
                        spawnBlock();
                        // Holdãƒ–ãƒ­ãƒƒã‚¯ã‚’æç”»ï¼ˆåˆæœŸçŠ¶æ…‹ã¯ç©ºï¼‰
                        drawHoldBlock();
                        // ã‚²ãƒ¼ãƒ ãƒ«ãƒ¼ãƒ—é–‹å§‹
                        gameLoop();
                    }, 250); // 0.5ç§’ã‹ã‚‰0.25ç§’ã«å¤‰æ›´ï¼ˆ2å€é€Ÿï¼‰
                }
            }
            
            // ãƒ©ãƒ³ãƒ€ãƒ ã«ãƒ–ãƒ­ãƒƒã‚¯ã‚¿ã‚¤ãƒ—ã‚’é¸ã¶
            // 7-Bag System: 7ç¨®é¡ã®ãƒ†ãƒˆãƒªãƒŸãƒã‚’1ã‚»ãƒƒãƒˆã¨ã—ã¦ã‚·ãƒ£ãƒƒãƒ•ãƒ«ã—ã¦æä¾›
            let pieceBag = [];
            
            // Fisher-Yatesã‚¢ãƒ«ã‚´ãƒªã‚ºãƒ ã§ã‚·ãƒ£ãƒƒãƒ•ãƒ«
            function shuffleArray(array) {
                const shuffled = [...array];
                for (let i = shuffled.length - 1; i > 0; i--) {
                    const j = Math.floor(Math.random() * (i + 1));
                    [shuffled[i], shuffled[j]] = [shuffled[j], shuffled[i]];
                }
                return shuffled;
            }
            
            // æ–°ã—ã„ãƒãƒƒã‚°ã‚’ç”Ÿæˆï¼ˆ7ç¨®é¡ã®ãƒ†ãƒˆãƒªãƒŸãƒã‚’ã‚·ãƒ£ãƒƒãƒ•ãƒ«ï¼‰
            function generateNewBag() {
                pieceBag = shuffleArray([...PIECE_TYPES]);
            }
            
            // ãƒãƒƒã‚°ã‹ã‚‰æ¬¡ã®ãƒ†ãƒˆãƒªãƒŸãƒã‚’å–å¾—
            function getNextPieceFromBag() {
                // ãƒãƒƒã‚°ãŒç©ºã®å ´åˆã¯æ–°ã—ã„ãƒãƒƒã‚°ã‚’ç”Ÿæˆ
                if (pieceBag.length === 0) {
                    generateNewBag();
                }
                // ãƒãƒƒã‚°ã®æœ€åˆã®è¦ç´ ã‚’å–å¾—ã—ã¦å‰Šé™¤
                return pieceBag.shift();
            }
            
            // æ¬¡ã®ãƒ–ãƒ­ãƒƒã‚¯ã‚’æº–å‚™ï¼ˆ5ã¤ï¼‰- 7-Bag Systemã‚’ä½¿ç”¨
            function prepareNextBlocks() {
                nextBlocks = [];
                for (let i = 0; i < 5; i++) {
                    const type = getNextPieceFromBag();
                    nextBlocks.push({
                        type: type,
                        shape: PIECE_SHAPES[type]
                    });
                }
            }
            
            // ãƒ–ãƒ­ãƒƒã‚¯ã‚’ç”Ÿæˆï¼ˆç”»é¢å¤–ã‹ã‚‰ï¼‰
            function spawnBlock() {
                // æ¬¡ã®ãƒ–ãƒ­ãƒƒã‚¯ãŒãªã‘ã‚Œã°æº–å‚™
                if (nextBlocks.length === 0) {
                    prepareNextBlocks();
                }
                
                // æœ€åˆã®ãƒ–ãƒ­ãƒƒã‚¯ã‚’å–å¾—
                const nextBlock = nextBlocks.shift();
                const type = nextBlock.type;
                const shape = [...nextBlock.shape]; // ã‚³ãƒ”ãƒ¼ã‚’ä½œæˆ
                
                // æ¬¡ã®ãƒ–ãƒ­ãƒƒã‚¯ã‚’1ã¤è¿½åŠ ï¼ˆå¸¸ã«5ã¤ä¿æŒï¼‰- 7-Bag Systemã‚’ä½¿ç”¨
                const newType = getNextPieceFromBag();
                nextBlocks.push({
                    type: newType,
                    shape: PIECE_SHAPES[newType]
                });
                
                // ãƒ–ãƒ­ãƒƒã‚¯ã®å¹…ã‚’è¨ˆç®—ã—ã¦ä¸­å¤®ã«é…ç½®
                const minX = Math.min(...shape.map(p => p.x));
                const maxX = Math.max(...shape.map(p => p.x));
                const width = maxX - minX + 1;
                const startX = Math.floor((BOARD_WIDTH - width) / 2) - minX;
                
                // ãƒ–ãƒ­ãƒƒã‚¯ã®å½¢çŠ¶ã®æœ€å¤§yåº§æ¨™ã‚’è¨ˆç®—
                const maxY = Math.max(...shape.map(p => p.y));
                
                // ãƒ–ãƒ­ãƒƒã‚¯å…¨ä½“ãŒç”»é¢å¤–ï¼ˆy < 0ï¼‰ã«ãªã‚‹ã‚ˆã†ã«åˆæœŸä½ç½®ã‚’è¨­å®š
                // ãƒ–ãƒ­ãƒƒã‚¯ã®æœ€ä¸‹éƒ¨ãŒy=-1ã«ãªã‚‹ã‚ˆã†ã«ã€åˆæœŸyã‚’-1 - maxYã«è¨­å®š
                const startY = -1 - maxY;
                
                currentBlock = {
                    type: type,
                    x: startX,
                    y: startY,  // ç”»é¢å¤–ã‹ã‚‰
                    shape: shape
                };
                canHold = true; // ãƒ›ãƒ¼ãƒ«ãƒ‰ã‚’å†åº¦å¯èƒ½ã«ã™ã‚‹
                console.log('Block spawned:', type, 'at:', currentBlock.x, currentBlock.y);
                
                // Nextãƒ–ãƒ­ãƒƒã‚¯è¡¨ç¤ºã‚’æ›´æ–°
                drawNextBlocks();
            }
            
            // ãƒ›ãƒ¼ãƒ«ãƒ‰æ©Ÿèƒ½
            function holdCurrentBlock() {
                if (!currentBlock || !canHold) return;
                
                if (holdBlock === null) {
                    // ãƒ›ãƒ¼ãƒ«ãƒ‰ãŒç©ºã®å ´åˆã€ç¾åœ¨ã®ãƒ–ãƒ­ãƒƒã‚¯ã‚’ãƒ›ãƒ¼ãƒ«ãƒ‰
                    holdBlock = {
                        type: currentBlock.type,
                        shape: [...currentBlock.shape]
                    };
                    // æ¬¡ã®ãƒ–ãƒ­ãƒƒã‚¯ã‚’ç”Ÿæˆ
                    spawnBlock();
                } else {
                    // ãƒ›ãƒ¼ãƒ«ãƒ‰ã«ãƒ–ãƒ­ãƒƒã‚¯ãŒã‚ã‚‹å ´åˆã€äº¤æ›
                    const temp = holdBlock;
                    holdBlock = {
                        type: currentBlock.type,
                        shape: [...currentBlock.shape]
                    };
                    
                    // ãƒ›ãƒ¼ãƒ«ãƒ‰ã—ã¦ã„ãŸãƒ–ãƒ­ãƒƒã‚¯ã‚’ç¾åœ¨ã®ãƒ–ãƒ­ãƒƒã‚¯ã¨ã—ã¦ç”Ÿæˆ
                    const type = temp.type;
                    const shape = [...temp.shape];
                    const minX = Math.min(...shape.map(p => p.x));
                    const maxX = Math.max(...shape.map(p => p.x));
                    const width = maxX - minX + 1;
                    const startX = Math.floor((BOARD_WIDTH - width) / 2) - minX;
                    
                    // ãƒ–ãƒ­ãƒƒã‚¯ã®å½¢çŠ¶ã®æœ€å¤§yåº§æ¨™ã‚’è¨ˆç®—
                    const maxY = Math.max(...shape.map(p => p.y));
                    // ãƒ–ãƒ­ãƒƒã‚¯å…¨ä½“ãŒç”»é¢å¤–ï¼ˆy < 0ï¼‰ã«ãªã‚‹ã‚ˆã†ã«åˆæœŸä½ç½®ã‚’è¨­å®š
                    const startY = -1 - maxY;
                    
                    currentBlock = {
                        type: type,
                        x: startX,
                        y: startY,
                        shape: shape
                    };
                }
                
                canHold = false; // 1å›ã®ãƒ”ãƒ¼ã‚¹ã«ã¤ã1å›ã®ã¿ãƒ›ãƒ¼ãƒ«ãƒ‰å¯èƒ½
                drawHoldBlock();
            }
            
            // ãƒ–ãƒ­ãƒƒã‚¯ãŒä¸€ç•ªä¸‹ã«åˆ°é”ã—ãŸã‹ãƒã‚§ãƒƒã‚¯
            function isBlockAtBottom() {
                if (!currentBlock) return false;
                // ãƒ–ãƒ­ãƒƒã‚¯ã®å½¢çŠ¶ã«å¿œã˜ã¦æœ€ä¸‹éƒ¨ã‚’ãƒã‚§ãƒƒã‚¯
                const maxY = Math.max(...currentBlock.shape.map(p => p.y));
                return currentBlock.y + maxY >= BOARD_HEIGHT - 1;
            }
            
            // ã‚´ãƒ¼ã‚¹ãƒˆãƒ”ãƒ¼ã‚¹ã®ä½ç½®ã‚’è¨ˆç®—ï¼ˆè½ä¸‹äºˆæ¸¬ä½ç½®ï¼‰
            function getGhostPosition() {
                if (!currentBlock) return null;
                
                let ghostY = currentBlock.y;
                // ä¸‹ã«ç§»å‹•ã§ãã‚‹é™ã‚Šç§»å‹•
                while (!hasCollision(currentBlock.x, ghostY + 1, currentBlock.shape)) {
                    const maxY = Math.max(...currentBlock.shape.map(p => p.y));
                    // ç”»é¢å†…ã®æœ€ä¸‹éƒ¨ã«åˆ°é”ã—ãŸã‚‰åœæ­¢
                    if (ghostY + maxY >= BOARD_HEIGHT - 1) break;
                    ghostY += 1;
                }
                
                return { x: currentBlock.x, y: ghostY };
            }
            
            // å®Œå…¨ã«åŸ‹ã¾ã£ã¦ã„ã‚‹è¡Œã‚’æ¤œå‡º
            function getFullRows() {
                // å„è¡Œã«ãƒ–ãƒ­ãƒƒã‚¯ãŒã‚ã‚‹ã‹ãƒã‚§ãƒƒã‚¯
                const rowCells = Array(BOARD_HEIGHT).fill(null).map(() => Array(BOARD_WIDTH).fill(false));
                
                // é…ç½®æ¸ˆã¿ãƒ–ãƒ­ãƒƒã‚¯ã®å„ã‚»ãƒ«ã‚’ãƒãƒ¼ã‚¯
                placedBlocks.forEach(block => {
                    block.shape.forEach(cell => {
                        const x = block.x + cell.x;
                        const y = block.y + cell.y;
                        if (x >= 0 && x < BOARD_WIDTH && y >= 0 && y < BOARD_HEIGHT) {
                            rowCells[y][x] = true;
                        }
                    });
                });
                
                // å®Œå…¨ã«åŸ‹ã¾ã£ã¦ã„ã‚‹è¡Œã‚’æ¤œå‡º
                const fullRows = [];
                for (let y = 0; y < BOARD_HEIGHT; y++) {
                    if (rowCells[y].every(cell => cell === true)) {
                        fullRows.push(y);
                    }
                }
                
                return fullRows;
            }
            
            // ã‚²ãƒ¼ãƒ ã‚ªãƒ¼ãƒãƒ¼åˆ¤å®šï¼ˆçœŸã‚“ä¸­4åˆ—ã®ç”»é¢ä¸Šéƒ¨ã«ãƒ–ãƒ­ãƒƒã‚¯ãŒç©ã¾ã‚ŒãŸå ´åˆï¼‰
            function checkGameOver() {
                // çœŸã‚“ä¸­4åˆ—ã¯åˆ—2, 3, 4, 5ï¼ˆã‚¤ãƒ³ãƒ‡ãƒƒã‚¯ã‚¹2, 3, 4, 5ï¼‰
                const centerColumns = [2, 3, 4, 5];
                
                // é…ç½®æ¸ˆã¿ãƒ–ãƒ­ãƒƒã‚¯ã‚’ãƒã‚§ãƒƒã‚¯
                for (const block of placedBlocks) {
                    for (const cell of block.shape) {
                        const x = block.x + cell.x;
                        const y = block.y + cell.y;
                        
                        // çœŸã‚“ä¸­4åˆ—ã®ç”»é¢ä¸Šéƒ¨ï¼ˆy < 0ï¼‰ã«ãƒ–ãƒ­ãƒƒã‚¯ãŒã‚ã‚‹ã‹ãƒã‚§ãƒƒã‚¯
                        if (centerColumns.includes(x) && y < 0) {
                            return true;
                        }
                    }
                }
                
                // ç¾åœ¨è½ä¸‹ä¸­ã®ãƒ–ãƒ­ãƒƒã‚¯ã‚‚ãƒã‚§ãƒƒã‚¯
                if (currentBlock) {
                    for (const cell of currentBlock.shape) {
                        const x = currentBlock.x + cell.x;
                        const y = currentBlock.y + cell.y;
                        
                        // çœŸã‚“ä¸­4åˆ—ã®ç”»é¢ä¸Šéƒ¨ï¼ˆy < 0ï¼‰ã«ãƒ–ãƒ­ãƒƒã‚¯ãŒã‚ã‚‹ã‹ãƒã‚§ãƒƒã‚¯
                        if (centerColumns.includes(x) && y < 0) {
                            return true;
                        }
                    }
                }
                
                return false;
            }
            
            // å®Œå…¨ã«åŸ‹ã¾ã£ã¦ã„ã‚‹è¡Œã‚’æ¶ˆå»ã—ã€ä¸Šã®ãƒ–ãƒ­ãƒƒã‚¯ã‚’ä¸‹ã«è½ã¨ã™
            function clearFullRows() {
                const fullRows = getFullRows();
                if (fullRows.length === 0) return;
                
                console.log('Clearing full rows:', fullRows);
                
                // æ¶ˆå»ã™ã‚‹è¡Œã‚’ã‚»ãƒƒãƒˆã¨ã—ã¦ä¿æŒï¼ˆé«˜é€Ÿæ¤œç´¢ã®ãŸã‚ï¼‰
                const fullRowsSet = new Set(fullRows);
                
                // ã™ã¹ã¦ã®ãƒ–ãƒ­ãƒƒã‚¯ã‹ã‚‰æ¶ˆå»ã™ã‚‹è¡Œã®ã‚»ãƒ«ã‚’ä¸€åº¦ã«å‰Šé™¤
                placedBlocks = placedBlocks.map(block => {
                    // æ¶ˆå»ã™ã‚‹è¡Œã«å«ã¾ã‚Œã‚‹ã‚»ãƒ«ã‚’é™¤å¤–
                    const filteredShape = block.shape.filter(cell => {
                        const y = block.y + cell.y;
                        return !fullRowsSet.has(y);
                    });
                    
                    // ã‚»ãƒ«ãŒæ®‹ã£ã¦ã„ã‚‹å ´åˆã®ã¿ãƒ–ãƒ­ãƒƒã‚¯ã‚’ä¿æŒ
                    if (filteredShape.length > 0) {
                        return {
                            ...block,
                            shape: filteredShape
                        };
                    }
                    return null;
                }).filter(block => block !== null);
                
                // æ¶ˆå»ã—ãŸè¡Œã‚ˆã‚Šä¸Šã«ã‚ã‚‹ãƒ–ãƒ­ãƒƒã‚¯ã‚’ã€æ¶ˆå»ã—ãŸè¡Œæ•°åˆ†ã ã‘ä¸‹ã«è½ã¨ã™
                // ä¸‹ã‹ã‚‰ä¸Šã«å‡¦ç†ã™ã‚‹ã“ã¨ã§ã€è¤‡æ•°è¡Œæ¶ˆå»æ™‚ã‚‚æ­£ã—ãå‹•ä½œ
                fullRows.sort((a, b) => b - a); // ä¸‹ã‹ã‚‰ä¸Šã«ã‚½ãƒ¼ãƒˆ
                
                placedBlocks.forEach(block => {
                    // ãƒ–ãƒ­ãƒƒã‚¯ã®æœ€å°yåº§æ¨™ã‚’è¨ˆç®—
                    if (block.shape.length > 0) {
                        const minY = Math.min(...block.shape.map(cell => block.y + cell.y));
                        // æ¶ˆå»ã—ãŸè¡Œã‚ˆã‚Šä¸Šã«ã‚ã‚‹ãƒ–ãƒ­ãƒƒã‚¯ã‚’ã€æ¶ˆå»ã—ãŸè¡Œæ•°åˆ†ã ã‘ä¸‹ã«ç§»å‹•
                        let dropCount = 0;
                        for (const clearedRow of fullRows) {
                            if (minY < clearedRow) {
                                dropCount++;
                            }
                        }
                        if (dropCount > 0) {
                            block.y += dropCount;
                        }
                    }
                });
                
                // ã‚¹ã‚³ã‚¢ã¨ãƒ©ã‚¤ãƒ³æ•°ã‚’æ›´æ–°
                const linesCleared = fullRows.length;
                const currentTime = performance.now();
                
                // ã‚³ãƒ³ãƒœåˆ¤å®šï¼ˆ2ç§’ä»¥å†…ã«é€£ç¶šã§ãƒ©ã‚¤ãƒ³ã‚’æ¶ˆå»ã—ãŸå ´åˆï¼‰
                if (currentTime - lastClearTime < COMBO_TIMEOUT && lastClearTime > 0) {
                    combo++;
                } else {
                    combo = 0; // ã‚³ãƒ³ãƒœãƒªã‚»ãƒƒãƒˆ
                }
                lastClearTime = currentTime;
                
                lines += linesCleared;
                score += calculateScore(linesCleared);
                updateLevel();
                updateScoreDisplay();
                
                // ãƒ©ã‚¤ãƒ³æ¶ˆå»æ•°ã®è¡¨ç¤º
                if (linesCleared > 0) {
                    showLineClearEffect(linesCleared);
                }
                
                // ãƒ†ãƒˆãƒªã‚¹ï¼ˆ4ãƒ©ã‚¤ãƒ³åŒæ™‚æ¶ˆå»ï¼‰ã®ç‰¹åˆ¥è¡¨ç¤º
                if (linesCleared === 4) {
                    console.log('TETRIS!');
                    // ãƒ†ãƒˆãƒªã‚¹æ™‚ã®ç‰¹åˆ¥ãªã‚¨ãƒ•ã‚§ã‚¯ãƒˆã¨ãƒ¡ãƒƒã‚»ãƒ¼ã‚¸ã‚’è¡¨ç¤º
                    showTetrisEffect();
                }
                
                // ã‚³ãƒ³ãƒœè¡¨ç¤º
                if (combo > 1) {
                    showComboEffect(combo);
                }
            
            // ãƒ©ã‚¤ãƒ³æ¶ˆå»ã‚¨ãƒ•ã‚§ã‚¯ãƒˆè¡¨ç¤º
            function showLineClearEffect(linesCleared) {
                const canvas = document.getElementById('game-canvas');
                const canvasRect = canvas.getBoundingClientRect();
                const centerX = canvasRect.left + canvasRect.width / 2;
                const centerY = canvasRect.top + canvasRect.height / 2;
                
                const lineClearElement = document.createElement('div');
                lineClearElement.className = 'line-clear-effect';
                lineClearElement.textContent = `${linesCleared} LINE${linesCleared > 1 ? 'S' : ''}!`;
                lineClearElement.style.cssText = `
                    position: fixed;
                    top: ${centerY}px;
                    left: ${centerX}px;
                    transform: translate(-50%, -50%);
                    font-size: 60px;
                    font-weight: bold;
                    color: #4caf50;
                    text-shadow: 0 0 10px #4caf50, 0 0 20px #4caf50;
                    z-index: 10002;
                    pointer-events: none;
                    animation: lineClearPulse 0.8s ease-out;
                `;
                document.body.appendChild(lineClearElement);
                
                setTimeout(() => {
                    lineClearElement.remove();
                }, 800);
            }
            
            // ã‚³ãƒ³ãƒœã‚¨ãƒ•ã‚§ã‚¯ãƒˆè¡¨ç¤º
            function showComboEffect(comboCount) {
                const canvas = document.getElementById('game-canvas');
                const canvasRect = canvas.getBoundingClientRect();
                const centerX = canvasRect.left + canvasRect.width / 2;
                const centerY = canvasRect.top + canvasRect.height / 2 - 100;
                
                const comboElement = document.createElement('div');
                comboElement.className = 'combo-effect';
                comboElement.textContent = `${comboCount}x COMBO!`;
                comboElement.style.cssText = `
                    position: fixed;
                    top: ${centerY}px;
                    left: ${centerX}px;
                    transform: translate(-50%, -50%);
                    font-size: 50px;
                    font-weight: bold;
                    color: #ff9800;
                    text-shadow: 0 0 10px #ff9800, 0 0 20px #ff9800;
                    z-index: 10002;
                    pointer-events: none;
                    animation: comboPulse 0.6s ease-out;
                `;
                document.body.appendChild(comboElement);
                
                setTimeout(() => {
                    comboElement.remove();
                }, 600);
            }
            
            // ãƒ†ãƒˆãƒªã‚¹ã‚¨ãƒ•ã‚§ã‚¯ãƒˆè¡¨ç¤º
            function showTetrisEffect() {
                const canvas = document.getElementById('game-canvas');
                const canvasRect = canvas.getBoundingClientRect();
                const centerX = canvasRect.left + canvasRect.width / 2;
                const centerY = canvasRect.top + canvasRect.height / 2;
                
                // ãƒ†ãƒˆãƒªã‚¹ãƒ¡ãƒƒã‚»ãƒ¼ã‚¸ã‚’è¡¨ç¤º
                const tetrisElement = document.createElement('div');
                tetrisElement.id = 'tetris-message';
                tetrisElement.textContent = 'TETRIS!';
                tetrisElement.style.cssText = `
                    position: fixed;
                    top: ${centerY}px;
                    left: ${centerX}px;
                    transform: translate(-50%, -50%);
                    font-size: 100px;
                    font-weight: bold;
                    color: #ffeb3b;
                    text-shadow: 0 0 20px #ff9800, 0 0 40px #ff9800;
                    z-index: 10002;
                    pointer-events: none;
                    animation: tetrisPulse 1s ease-out;
                `;
                document.body.appendChild(tetrisElement);
                
                // 1ç§’å¾Œã«å‰Šé™¤
                setTimeout(() => {
                    tetrisElement.remove();
                }, 1000);
            }
                
                console.log('Rows cleared:', linesCleared, 'Combo:', combo, 'Total lines:', lines, 'Score:', score, 'Level:', level);
            }
            
            // ãƒ–ãƒ­ãƒƒã‚¯ã‚’å›è»¢ã•ã›ã‚‹ï¼ˆæ™‚è¨ˆå›ã‚Š90åº¦ï¼‰
            function rotateClockwise(shape) {
                return shape.map(cell => ({ x: -cell.y, y: cell.x }));
            }
            
            // ãƒ–ãƒ­ãƒƒã‚¯ã‚’å›è»¢ã•ã›ã‚‹ï¼ˆåæ™‚è¨ˆå›ã‚Š90åº¦ï¼‰
            function rotateCounterClockwise(shape) {
                return shape.map(cell => ({ x: cell.y, y: -cell.x }));
            }
            
            // ãƒ–ãƒ­ãƒƒã‚¯ãŒä»–ã®ãƒ–ãƒ­ãƒƒã‚¯ã¨è¡çªã—ã¦ã„ã‚‹ã‹ãƒã‚§ãƒƒã‚¯
            function hasCollision(newX, newY, shape) {
                if (!shape) shape = currentBlock.shape;
                
                // ãƒ–ãƒ­ãƒƒã‚¯ã®å„ã‚»ãƒ«ã‚’ãƒã‚§ãƒƒã‚¯
                for (const cell of shape) {
                    const checkX = newX + cell.x;
                    const checkY = newY + cell.y;
                    
                    // å£ã¨ã®è¡çªãƒã‚§ãƒƒã‚¯ï¼ˆæ¨ªæ–¹å‘ã®ã¿ï¼‰
                    if (checkX < 0 || checkX >= BOARD_WIDTH) {
                        return true;
                    }
                    
                    // ç”»é¢å†…ã®ã‚»ãƒ«ã®ã¿è¡çªãƒã‚§ãƒƒã‚¯
                    if (checkY >= 0 && checkY < BOARD_HEIGHT) {
                        // é…ç½®æ¸ˆã¿ãƒ–ãƒ­ãƒƒã‚¯ã¨ã®è¡çªãƒã‚§ãƒƒã‚¯
                        for (const placedBlock of placedBlocks) {
                            for (const placedCell of placedBlock.shape) {
                                const placedX = placedBlock.x + placedCell.x;
                                const placedY = placedBlock.y + placedCell.y;
                                // ç”»é¢å†…ã®é…ç½®æ¸ˆã¿ãƒ–ãƒ­ãƒƒã‚¯ã¨ã®ã¿è¡çªãƒã‚§ãƒƒã‚¯
                                if (placedY >= 0 && placedX === checkX && placedY === checkY) {
                                    return true;
                                }
                            }
                        }
                    }
                }
                return false;
            }
            
            // ã‚¤ãƒ™ãƒ³ãƒˆãƒªã‚¹ãƒŠãƒ¼ã®é‡è¤‡ç™»éŒ²å¯¾ç­–
            let keydownHandler = null;
            
            // ã‚­ãƒ¼å…¥åŠ›å‡¦ç†ï¼ˆé‡è¤‡ç™»éŒ²ã‚’é˜²ãï¼‰
            function setupKeydownHandler() {
                if (keydownHandler) {
                    document.removeEventListener('keydown', keydownHandler);
                }
                keydownHandler = (e) => {
                // ã‚²ãƒ¼ãƒ ã‚ªãƒ¼ãƒãƒ¼æ™‚ã®Enterã‚­ãƒ¼å‡¦ç†
                if (gameOver && e.key === 'Enter') {
                    e.preventDefault();
                    resetGame();
                    return;
                }
                
                if (!gameActive || !currentBlock || gameOver) return;
                
                switch(e.key) {
                    case 'ArrowLeft':
                        // å·¦ã«ç§»å‹•
                        e.preventDefault();
                        if (!hasCollision(currentBlock.x - 1, currentBlock.y, currentBlock.shape)) {
                            currentBlock.x -= 1;
                        }
                        break;
                    case 'ArrowRight':
                        // å³ã«ç§»å‹•
                        e.preventDefault();
                        if (!hasCollision(currentBlock.x + 1, currentBlock.y, currentBlock.shape)) {
                            currentBlock.x += 1;
                        }
                        break;
                    case 'ArrowDown':
                        // ã‚½ãƒ•ãƒˆãƒ‰ãƒ­ãƒƒãƒ—ï¼ˆä¸‹ã«ç§»å‹•ï¼‰
                        e.preventDefault(); // ã‚¹ã‚¯ãƒ­ãƒ¼ãƒ«ã‚’é˜²ã
                        if (!hasCollision(currentBlock.x, currentBlock.y + 1, currentBlock.shape)) {
                            currentBlock.y += 1;
                            dropTimer = 0; // ã‚¿ã‚¤ãƒãƒ¼ãƒªã‚»ãƒƒãƒˆ
                            // ã‚½ãƒ•ãƒˆãƒ‰ãƒ­ãƒƒãƒ—æ™‚ã«1ãƒã‚¹ã‚ãŸã‚Š1ç‚¹ã‚’åŠ ç®—
                            softDropScore += 1;
                            score += 1;
                            updateScoreDisplay();
                        }
                        break;
                    case 'z':
                    case 'Z':
                        // å·¦å›è»¢ï¼ˆåæ™‚è¨ˆå›ã‚Šï¼‰
                        e.preventDefault();
                        const rotatedLeft = rotateCounterClockwise(currentBlock.shape);
                        if (!hasCollision(currentBlock.x, currentBlock.y, rotatedLeft)) {
                            currentBlock.shape = rotatedLeft;
                            // å›è»¢æ™‚ã®è¦–è¦šçš„ãƒ•ã‚£ãƒ¼ãƒ‰ãƒãƒƒã‚¯
                            showRotationFeedback('left');
                        }
                        break;
                    case 'x':
                    case 'X':
                        // å³å›è»¢ï¼ˆæ™‚è¨ˆå›ã‚Šï¼‰
                        e.preventDefault();
                        const rotatedRight = rotateClockwise(currentBlock.shape);
                        if (!hasCollision(currentBlock.x, currentBlock.y, rotatedRight)) {
                            currentBlock.shape = rotatedRight;
                            // å›è»¢æ™‚ã®è¦–è¦šçš„ãƒ•ã‚£ãƒ¼ãƒ‰ãƒãƒƒã‚¯
                            showRotationFeedback('right');
                        }
                        break;
                    case 'c':
                    case 'C':
                        // ãƒ›ãƒ¼ãƒ«ãƒ‰
                        e.preventDefault();
                        holdCurrentBlock();
                        break;
                    case 'g':
                    case 'G':
                        // ã‚°ãƒªãƒƒãƒ‰è¡¨ç¤ºã®ãƒˆã‚°ãƒ«
                        e.preventDefault();
                        showGrid = !showGrid;
                        break;
                    case 'p':
                    case 'P':
                        // ãƒãƒ¼ã‚º/å†é–‹
                        e.preventDefault();
                        if (gameActive && !gameOver) {
                            gameActive = !gameActive;
                            if (gameActive) {
                                lastTime = performance.now();
                                gameLoop();
                            }
                        }
                        break;
                    case 'r':
                    case 'R':
                        // ãƒªã‚¹ã‚¿ãƒ¼ãƒˆ
                        e.preventDefault();
                        if (gameOver || !gameActive) {
                            resetGame();
                        }
                        break;
                    case ' ':
                    case 'Space':
                        // ãƒãƒ¼ãƒ‰ãƒ‰ãƒ­ãƒƒãƒ—ï¼ˆä¸€æ°—ã«ä¸‹ã«è½ã¨ã™ï¼‰
                        e.preventDefault();
                        let dropY = currentBlock.y;
                        const startY = dropY;
                        
                        // ãƒãƒ¼ãƒ‰ãƒ‰ãƒ­ãƒƒãƒ—æ™‚ã®è»Œè·¡ã‚’è¡¨ç¤º
                        const dropTrail = [];
                        while (!hasCollision(currentBlock.x, dropY + 1, currentBlock.shape)) {
                            const maxY = Math.max(...currentBlock.shape.map(p => p.y));
                            if (dropY + maxY >= BOARD_HEIGHT - 1) break;
                            dropY += 1;
                            dropTrail.push(dropY);
                        }
                        
                        // è»Œè·¡ã‚’æç”»ï¼ˆçŸ­æ™‚é–“ï¼‰
                        if (dropTrail.length > 0) {
                            showHardDropTrail(dropTrail);
                        }
                        
                        currentBlock.y = dropY;
                        // å³åº§ã«å›ºå®šï¼ˆç”»é¢å†…ã®ã‚»ãƒ«ã®ã¿ä¿å­˜ï¼‰
                        const placedShape = currentBlock.shape.filter(cell => {
                            const y = currentBlock.y + cell.y;
                            return y >= 0 && y < BOARD_HEIGHT;
                        });
                        if (placedShape.length > 0) {
                            placedBlocks.push({
                                type: currentBlock.type,
                                x: currentBlock.x,
                                y: currentBlock.y,
                                shape: placedShape
                            });
                        }
                        // å®Œå…¨ã«åŸ‹ã¾ã£ã¦ã„ã‚‹è¡Œã‚’æ¶ˆå»
                        clearFullRows();
                        spawnBlock();
                        break;
                }
                };
                document.addEventListener('keydown', keydownHandler);
            }
            
            // ã‚­ãƒ¼å…¥åŠ›ãƒãƒ³ãƒ‰ãƒ©ãƒ¼ã‚’è¨­å®š
            setupKeydownHandler();
            
            // è‰²ã®æ˜åº¦ã‚’èª¿æ•´ã™ã‚‹é–¢æ•°
            function adjustColorBrightness(hex, percent) {
                const num = parseInt(hex.replace('#', ''), 16);
                const r = Math.min(255, Math.max(0, (num >> 16) + percent));
                const g = Math.min(255, Math.max(0, ((num >> 8) & 0x00FF) + percent));
                const b = Math.min(255, Math.max(0, (num & 0x0000FF) + percent));
                return '#' + ((1 << 24) + (r << 16) + (g << 8) + b).toString(16).slice(1);
            }
            
            // èƒŒæ™¯ã‚’æç”»
            function drawBackground() {
                // èƒŒæ™¯è‰²ã§å¡—ã‚Šã¤ã¶ã—
                ctx.fillStyle = BG_COLOR;
                ctx.fillRect(0, 0, canvas.width, canvas.height);
                
                // ãƒœãƒ¼ãƒ‰ã®å¢ƒç•Œç·šã‚’å¼·èª¿
                ctx.strokeStyle = 'rgba(255, 255, 255, 0.5)';
                ctx.lineWidth = 3;
                ctx.strokeRect(0, 0, canvas.width, canvas.height);
                
                // ã‚°ãƒªãƒƒãƒ‰ç·šã‚’æç”»ï¼ˆshowGridãƒ•ãƒ©ã‚°ãŒtrueã®å ´åˆã®ã¿ï¼‰
                if (showGrid) {
                    ctx.strokeStyle = 'rgba(139, 148, 158, 0.3)'; // è–„ã„ã‚°ãƒªãƒƒãƒ‰è‰²
                    ctx.lineWidth = 1;
                    
                    // ç¸¦ç·šã‚’æç”»
                    for (let x = 0; x <= BOARD_WIDTH; x++) {
                        ctx.beginPath();
                        ctx.moveTo(x * CELL_SIZE, 0);
                        ctx.lineTo(x * CELL_SIZE, canvas.height);
                        ctx.stroke();
                    }
                    
                    // æ¨ªç·šã‚’æç”»
                    for (let y = 0; y <= BOARD_HEIGHT; y++) {
                        ctx.beginPath();
                        ctx.moveTo(0, y * CELL_SIZE);
                        ctx.lineTo(canvas.width, y * CELL_SIZE);
                        ctx.stroke();
                    }
                }
            }
            
            // ãƒ–ãƒ­ãƒƒã‚¯ã‚’æç”»
            function drawBlock(blockX, blockY, shape, color, isGhost = false) {
                // ãƒ–ãƒ­ãƒƒã‚¯ã®å„ã‚»ãƒ«ã‚’æç”»ï¼ˆç”»é¢å†…ã®ã‚»ãƒ«ã®ã¿ï¼‰
                for (const cell of shape) {
                    const cellY = blockY + cell.y;
                    // ç”»é¢å†…ã®ã‚»ãƒ«ã®ã¿æç”»
                    if (cellY < 0 || cellY >= BOARD_HEIGHT) continue;
                    
                    const x = (blockX + cell.x) * CELL_SIZE;
                    const y = cellY * CELL_SIZE;
                    
                    if (isGhost) {
                        // ã‚´ãƒ¼ã‚¹ãƒˆãƒ”ãƒ¼ã‚¹ã¯è–„ãè¡¨ç¤ºï¼ˆè¦–èªæ€§å‘ä¸Šï¼‰
                        ctx.strokeStyle = color;
                        ctx.lineWidth = 3; // ç‚¹ç·šã®å¤ªã•ã‚’å¢—åŠ 
                        ctx.globalAlpha = 0.5; // é€æ˜åº¦ã‚’ä¸Šã’ã¦è¦–èªæ€§å‘ä¸Š
                        ctx.setLineDash([6, 4]); // ç‚¹ç·šã®ãƒ‘ã‚¿ãƒ¼ãƒ³ã‚’èª¿æ•´
                        ctx.strokeRect(x + 2, y + 2, CELL_SIZE - 4, CELL_SIZE - 4);
                        ctx.setLineDash([]); // ç‚¹ç·šã‚’ãƒªã‚»ãƒƒãƒˆ
                        ctx.globalAlpha = 1.0; // é€æ˜åº¦ã‚’ãƒªã‚»ãƒƒãƒˆ
                    } else {
                        // é€šå¸¸ã®ãƒ–ãƒ­ãƒƒã‚¯
                        // ã‚°ãƒ©ãƒ‡ãƒ¼ã‚·ãƒ§ãƒ³åŠ¹æœã‚’è¿½åŠ 
                        const gradient = ctx.createLinearGradient(x, y, x + CELL_SIZE, y + CELL_SIZE);
                        gradient.addColorStop(0, color);
                        gradient.addColorStop(1, adjustColorBrightness(color, -20));
                        ctx.fillStyle = gradient;
                        ctx.fillRect(x + 2, y + 2, CELL_SIZE - 4, CELL_SIZE - 4);
                        
                        // ãƒ‰ãƒ­ãƒƒãƒ—ã‚·ãƒ£ãƒ‰ã‚¦ã‚’è¿½åŠ 
                        ctx.shadowColor = 'rgba(0, 0, 0, 0.3)';
                        ctx.shadowBlur = 4;
                        ctx.shadowOffsetX = 2;
                        ctx.shadowOffsetY = 2;
                        
                        // ç™½ã„ã‚¢ã‚¦ãƒˆãƒ©ã‚¤ãƒ³
                        ctx.strokeStyle = '#ffffff';
                        ctx.lineWidth = 2;
                        ctx.strokeRect(x + 2, y + 2, CELL_SIZE - 4, CELL_SIZE - 4);
                        
                        // ã‚·ãƒ£ãƒ‰ã‚¦ã‚’ãƒªã‚»ãƒƒãƒˆ
                        ctx.shadowColor = 'transparent';
                        ctx.shadowBlur = 0;
                        ctx.shadowOffsetX = 0;
                        ctx.shadowOffsetY = 0;
                    }
                }
            }
            
            // Holdãƒ–ãƒ­ãƒƒã‚¯ã‚’æç”»
            function drawHoldBlock() {
                // èƒŒæ™¯ã‚’ã‚¯ãƒªã‚¢ï¼ˆèƒŒæ™¯è‰²ã‚’å°‘ã—æ˜ã‚‹ãã—ã¦è¦–èªæ€§å‘ä¸Šï¼‰
                holdCtx.fillStyle = adjustColorBrightness(BG_COLOR, 10);
                holdCtx.fillRect(0, 0, holdCanvas.width, holdCanvas.height);
                
                if (holdBlock) {
                    const color = PIECE_COLORS[holdBlock.type];
                    
                    // ãƒ–ãƒ­ãƒƒã‚¯ã®ä¸­å¿ƒã‚’è¨ˆç®—
                    const minX = Math.min(...holdBlock.shape.map(p => p.x));
                    const maxX = Math.max(...holdBlock.shape.map(p => p.x));
                    const minY = Math.min(...holdBlock.shape.map(p => p.y));
                    const maxY = Math.max(...holdBlock.shape.map(p => p.y));
                    const blockWidth = (maxX - minX + 1) * HOLD_CELL_SIZE;
                    const blockHeight = (maxY - minY + 1) * HOLD_CELL_SIZE;
                    const centerX = (holdCanvas.width - blockWidth) / 2;
                    const centerY = (holdCanvas.height - blockHeight) / 2;
                    
                    // ãƒ–ãƒ­ãƒƒã‚¯ã®å„ã‚»ãƒ«ã‚’æç”»ï¼ˆã‚°ãƒ©ãƒ‡ãƒ¼ã‚·ãƒ§ãƒ³åŠ¹æœã‚’è¿½åŠ ï¼‰
                    holdBlock.shape.forEach(cell => {
                        const x = centerX + (cell.x - minX) * HOLD_CELL_SIZE;
                        const y = centerY + (cell.y - minY) * HOLD_CELL_SIZE;
                        
                        // ã‚°ãƒ©ãƒ‡ãƒ¼ã‚·ãƒ§ãƒ³åŠ¹æœ
                        const gradient = holdCtx.createLinearGradient(x, y, x + HOLD_CELL_SIZE, y + HOLD_CELL_SIZE);
                        gradient.addColorStop(0, color);
                        gradient.addColorStop(1, adjustColorBrightness(color, -15));
                        holdCtx.fillStyle = gradient;
                        holdCtx.fillRect(x + 1, y + 1, HOLD_CELL_SIZE - 2, HOLD_CELL_SIZE - 2);
                        
                        // ç™½ã„ã‚¢ã‚¦ãƒˆãƒ©ã‚¤ãƒ³
                        holdCtx.strokeStyle = '#ffffff';
                        holdCtx.lineWidth = 1;
                        holdCtx.strokeRect(x + 1, y + 1, HOLD_CELL_SIZE - 2, HOLD_CELL_SIZE - 2);
                    });
                }
            }
            
            // Nextãƒ–ãƒ­ãƒƒã‚¯ã‚’æç”»
            function drawNextBlocks() {
                // èƒŒæ™¯ã‚’ã‚¯ãƒªã‚¢ï¼ˆèƒŒæ™¯è‰²ã‚’å°‘ã—æ˜ã‚‹ãã—ã¦è¦–èªæ€§å‘ä¸Šï¼‰
                nextCtx.fillStyle = adjustColorBrightness(BG_COLOR, 10);
                nextCtx.fillRect(0, 0, nextCanvas.width, nextCanvas.height);
                
                // å„Nextãƒ–ãƒ­ãƒƒã‚¯ã‚’æç”»ï¼ˆæœ€å¤§5ã¤ï¼‰
                const blockHeight = 100; // å„ãƒ–ãƒ­ãƒƒã‚¯ã®é«˜ã•
                const startY = 20; // é–‹å§‹ä½ç½®
                
                nextBlocks.slice(0, 5).forEach((block, index) => {
                    const y = startY + index * blockHeight;
                    const color = PIECE_COLORS[block.type];
                    
                    // ãƒ–ãƒ­ãƒƒã‚¯ã®ä¸­å¿ƒã‚’è¨ˆç®—
                    const minX = Math.min(...block.shape.map(p => p.x));
                    const maxX = Math.max(...block.shape.map(p => p.x));
                    const minY = Math.min(...block.shape.map(p => p.y));
                    const maxY = Math.max(...block.shape.map(p => p.y));
                    const blockWidth = (maxX - minX + 1) * NEXT_CELL_SIZE;
                    const blockHeight2 = (maxY - minY + 1) * NEXT_CELL_SIZE;
                    const centerX = (nextCanvas.width - blockWidth) / 2;
                    
                    // ãƒ–ãƒ­ãƒƒã‚¯ã®å„ã‚»ãƒ«ã‚’æç”»ï¼ˆã‚°ãƒ©ãƒ‡ãƒ¼ã‚·ãƒ§ãƒ³åŠ¹æœã‚’è¿½åŠ ï¼‰
                    block.shape.forEach(cell => {
                        const x = centerX + (cell.x - minX) * NEXT_CELL_SIZE;
                        const cellY = y + (cell.y - minY) * NEXT_CELL_SIZE;
                        
                        // ã‚°ãƒ©ãƒ‡ãƒ¼ã‚·ãƒ§ãƒ³åŠ¹æœ
                        const gradient = nextCtx.createLinearGradient(x, cellY, x + NEXT_CELL_SIZE, cellY + NEXT_CELL_SIZE);
                        gradient.addColorStop(0, color);
                        gradient.addColorStop(1, adjustColorBrightness(color, -15));
                        nextCtx.fillStyle = gradient;
                        nextCtx.fillRect(x + 1, cellY + 1, NEXT_CELL_SIZE - 2, NEXT_CELL_SIZE - 2);
                        
                        // ç™½ã„ã‚¢ã‚¦ãƒˆãƒ©ã‚¤ãƒ³
                        nextCtx.strokeStyle = '#ffffff';
                        nextCtx.lineWidth = 1;
                        nextCtx.strokeRect(x + 1, cellY + 1, NEXT_CELL_SIZE - 2, NEXT_CELL_SIZE - 2);
                    });
                });
            }
            
            // ãƒ–ãƒ­ãƒƒã‚¯ã‚’æç”»ï¼ˆç¾åœ¨ã®ãƒ–ãƒ­ãƒƒã‚¯ã¨é…ç½®æ¸ˆã¿ãƒ–ãƒ­ãƒƒã‚¯ï¼‰
            function drawBlocks() {
                // ã‚´ãƒ¼ã‚¹ãƒˆãƒ”ãƒ¼ã‚¹ã‚’æç”»ï¼ˆç¾åœ¨ã®ãƒ–ãƒ­ãƒƒã‚¯ã®è½ä¸‹äºˆæ¸¬ä½ç½®ï¼‰
                if (currentBlock) {
                    const ghostPos = getGhostPosition();
                    if (ghostPos && ghostPos.y !== currentBlock.y) {
                        const ghostColor = PIECE_COLORS[currentBlock.type];
                        drawBlock(ghostPos.x, ghostPos.y, currentBlock.shape, ghostColor, true);
                    }
                    
                    // ãƒãƒ¼ãƒ‰ãƒ‰ãƒ­ãƒƒãƒ—æ™‚ã®è»Œè·¡ã‚’æç”»
                    if (window.hardDropTrail && window.hardDropTrail.length > 0) {
                        const trailColor = PIECE_COLORS[currentBlock.type];
                        window.hardDropTrail.forEach(trailY => {
                            ctx.save();
                            ctx.globalAlpha = 0.3;
                            currentBlock.shape.forEach(cell => {
                                const y = trailY + cell.y;
                                if (y >= 0 && y < BOARD_HEIGHT) {
                                    const x = (currentBlock.x + cell.x) * CELL_SIZE;
                                    const cellY = y * CELL_SIZE;
                                    ctx.fillStyle = trailColor;
                                    ctx.fillRect(x + 2, cellY + 2, CELL_SIZE - 4, CELL_SIZE - 4);
                                }
                            });
                            ctx.restore();
                        });
                    }
                }
                
                // é…ç½®æ¸ˆã¿ãƒ–ãƒ­ãƒƒã‚¯ã‚’æç”»
                placedBlocks.forEach(block => {
                    const color = PIECE_COLORS[block.type];
                    drawBlock(block.x, block.y, block.shape, color);
                });
                
                // ç¾åœ¨ã®ãƒ–ãƒ­ãƒƒã‚¯ã‚’æç”»ï¼ˆæœ€å¾Œã«æç”»ã—ã¦å‰é¢ã«è¡¨ç¤ºï¼‰
                if (currentBlock) {
                    const color = PIECE_COLORS[currentBlock.type];
                    drawBlock(currentBlock.x, currentBlock.y, currentBlock.shape, color);
                }
            }
            
            // ã‚²ãƒ¼ãƒ æ›´æ–°
            function update(deltaTime) {
                if (!gameActive || !currentBlock || gameOver) return;
                
                dropTimer += deltaTime;
                
                // ç¾åœ¨ã®è½ä¸‹é–“éš”ã‚’ä½¿ç”¨ï¼ˆãƒ¬ãƒ™ãƒ«ã«å¿œã˜ã¦å¤‰åŒ–ï¼‰
                const currentDropInterval = window.currentDropInterval || DROP_INTERVAL_BASE;
                
                if (dropTimer >= currentDropInterval) {
                    dropTimer = 0;
                    
                    // ãƒ–ãƒ­ãƒƒã‚¯ã‚’ä¸‹ã«ç§»å‹•
                    if (isBlockAtBottom() || hasCollision(currentBlock.x, currentBlock.y + 1, currentBlock.shape)) {
                        // ä¸€ç•ªä¸‹ã«åˆ°é”ã—ãŸã‹ã€ä»–ã®ãƒ–ãƒ­ãƒƒã‚¯ã¨è¡çªã—ãŸã‚‰ã€ç¾åœ¨ã®ãƒ–ãƒ­ãƒƒã‚¯ã‚’é…ç½®æ¸ˆã¿ãƒ–ãƒ­ãƒƒã‚¯ã«è¿½åŠ 
                        console.log('Block reached bottom or collision, placing block');
                        // ç”»é¢å†…ã®ã‚»ãƒ«ã®ã¿ä¿å­˜
                        const placedShape = currentBlock.shape.filter(cell => {
                            const y = currentBlock.y + cell.y;
                            return y >= 0 && y < BOARD_HEIGHT;
                        });
                        if (placedShape.length > 0) {
                            placedBlocks.push({
                                type: currentBlock.type,
                                x: currentBlock.x,
                                y: currentBlock.y,
                                shape: placedShape
                            });
                        }
                        // å®Œå…¨ã«åŸ‹ã¾ã£ã¦ã„ã‚‹è¡Œã‚’æ¶ˆå»
                        clearFullRows();
                        
                        // ã‚²ãƒ¼ãƒ ã‚ªãƒ¼ãƒãƒ¼åˆ¤å®š
                        if (checkGameOver()) {
                            gameOver = true;
                            gameActive = false;
                            // 1ç§’å¾Œã«ãƒªãƒˆãƒ©ã‚¤ãƒ¡ãƒƒã‚»ãƒ¼ã‚¸ã‚’è¡¨ç¤º
                            setTimeout(() => {
                                showRetryMessage = true;
                            }, 1000);
                            return;
                        }
                        
                        // æ¬¡ã®ãƒ–ãƒ­ãƒƒã‚¯ã‚’ç”Ÿæˆ
                        spawnBlock();
                    } else {
                        // ã¾ã ä¸‹ã«ç§»å‹•ã§ãã‚‹
                        currentBlock.y += 1;
                    }
                }
            }
            
            // ã‚²ãƒ¼ãƒ ã‚ªãƒ¼ãƒãƒ¼ç”»é¢ã‚’æç”»
            function drawGameOver() {
                let gameOverElement = document.getElementById('game-over-overlay');
                
                if (!gameOver) {
                    // ã‚²ãƒ¼ãƒ ã‚ªãƒ¼ãƒãƒ¼è¦ç´ ã‚’éè¡¨ç¤º
                    if (gameOverElement) {
                        gameOverElement.classList.add('hidden');
                    }
                    return;
                }
                
                // ã‚²ãƒ¼ãƒ ã‚ªãƒ¼ãƒãƒ¼è¦ç´ ã‚’è¡¨ç¤º
                if (!gameOverElement) {
                    // ã‚²ãƒ¼ãƒ ã‚ªãƒ¼ãƒãƒ¼ã‚ªãƒ¼ãƒãƒ¼ãƒ¬ã‚¤ã‚’ä½œæˆ
                    gameOverElement = document.createElement('div');
                    gameOverElement.id = 'game-over-overlay';
                    gameOverElement.innerHTML = `
                        <div class="game-over-content">
                            <div id="game-over-text" class="game-over-text">Game Over</div>
                            <div id="final-score" class="final-score">Score: <span id="final-score-value">0</span></div>
                            <div id="final-level" class="final-level">Level: <span id="final-level-value">1</span></div>
                            <div id="final-lines" class="final-lines">Lines: <span id="final-lines-value">0</span></div>
                            <div id="retry-message" class="retry-message hidden">Press Enter To Retry</div>
                        </div>
                    `;
                    document.getElementById('game-screen').appendChild(gameOverElement);
                }
                
                gameOverElement.classList.remove('hidden');
                
                // çµ±è¨ˆãƒ‡ãƒ¼ã‚¿ã‚’æ›´æ–°
                if (gameStartTime) {
                    const playTime = Math.floor((performance.now() - gameStartTime) / 1000);
                    gameStats.totalPlayTime += playTime;
                    gameStats.totalScore += score;
                    gameStats.totalGames += 1;
                    gameStats.maxLevel = Math.max(gameStats.maxLevel, level);
                    gameStats.maxLines = Math.max(gameStats.maxLines, lines);
                    
                    // ãƒ­ãƒ¼ã‚«ãƒ«ã‚¹ãƒˆãƒ¬ãƒ¼ã‚¸ã«ä¿å­˜
                    localStorage.setItem('tetrisTotalPlayTime', gameStats.totalPlayTime.toString());
                    localStorage.setItem('tetrisTotalScore', gameStats.totalScore.toString());
                    localStorage.setItem('tetrisTotalGames', gameStats.totalGames.toString());
                    localStorage.setItem('tetrisMaxLevel', gameStats.maxLevel.toString());
                    localStorage.setItem('tetrisMaxLines', gameStats.maxLines.toString());
                    
                    // ã‚²ãƒ¼ãƒ å±¥æ­´ã«è¿½åŠ 
                    const gameHistory = JSON.parse(localStorage.getItem('tetrisGameHistory') || '[]');
                    gameHistory.push({
                        score: score,
                        level: level,
                        lines: lines,
                        playTime: playTime,
                        date: new Date().toISOString()
                    });
                    // æœ€æ–°100ä»¶ã®ã¿ä¿æŒ
                    if (gameHistory.length > 100) {
                        gameHistory.shift();
                    }
                    localStorage.setItem('tetrisGameHistory', JSON.stringify(gameHistory));
                    
                    gameStartTime = null;
                }
                
                // ã‚²ãƒ¼ãƒ ã‚ªãƒ¼ãƒãƒ¼ç”»é¢ã®ã‚¢ãƒ‹ãƒ¡ãƒ¼ã‚·ãƒ§ãƒ³æ”¹å–„
                const gameOverText = gameOverElement.querySelector('#game-over-text');
                if (gameOverText) {
                    gameOverText.style.animation = 'gameOverPulse 1.5s ease-in-out infinite';
                }
                
                // ãƒªãƒˆãƒ©ã‚¤ãƒ¡ãƒƒã‚»ãƒ¼ã‚¸ã‚’é…å»¶è¡¨ç¤º
                setTimeout(() => {
                    const retryMessage = gameOverElement.querySelector('#retry-message');
                    if (retryMessage) {
                        retryMessage.classList.remove('hidden');
                        retryMessage.style.animation = 'blink 1.5s ease-in-out infinite';
                    }
                }, 1000);
                
                // æœ€çµ‚ã‚¹ã‚³ã‚¢ã‚’è¡¨ç¤º
                const finalScoreValue = gameOverElement.querySelector('#final-score-value');
                const finalLevelValue = gameOverElement.querySelector('#final-level-value');
                const finalLinesValue = gameOverElement.querySelector('#final-lines-value');
                if (finalScoreValue) finalScoreValue.textContent = score.toLocaleString();
                if (finalLevelValue) finalLevelValue.textContent = level;
                if (finalLinesValue) finalLinesValue.textContent = lines;
                
                // ãƒªãƒˆãƒ©ã‚¤ãƒ¡ãƒƒã‚»ãƒ¼ã‚¸ã®è¡¨ç¤º/éè¡¨ç¤º
                const retryMessage = gameOverElement.querySelector('#retry-message');
                if (retryMessage) {
                    if (showRetryMessage) {
                        retryMessage.classList.remove('hidden');
                    } else {
                        retryMessage.classList.add('hidden');
                    }
                }
                
                // Canvasä¸Šã«ã‚‚æš—ã„ã‚ªãƒ¼ãƒãƒ¼ãƒ¬ã‚¤ã‚’æç”»
                ctx.fillStyle = 'rgba(0, 0, 0, 0.6)';
                ctx.fillRect(0, 0, canvas.width, canvas.height);
            }
            
            // ã‚²ãƒ¼ãƒ ãƒªã‚»ãƒƒãƒˆ
            function resetGame() {
                // ã‚²ãƒ¼ãƒ ãƒ«ãƒ¼ãƒ—ã‚’åœæ­¢
                stopGameLoop();
                
                currentBlock = null;
                placedBlocks = [];
                nextBlocks = [];
                holdBlock = null;
                canHold = true;
                dropTimer = 0;
                lastTime = performance.now();
                gameActive = false;
                gameOver = false;
                showRetryMessage = false;
                countdown = 3;
                score = 0;
                level = 1;
                lines = 0;
                combo = 0;
                softDropScore = 0;
                lastClearTime = 0;
                window.currentDropInterval = DROP_INTERVAL_BASE;
                updateDropInterval(); // æ‰‹å‹•é€Ÿåº¦è¨­å®šã‚’åæ˜ 
                
                // ãƒã‚¤ã‚¹ã‚³ã‚¢è¡¨ç¤ºã‚’æ›´æ–°
                updateHighScoreDisplay();
                updateScoreDisplay();
                
                // ã‚²ãƒ¼ãƒ ã‚ªãƒ¼ãƒãƒ¼ã‚ªãƒ¼ãƒãƒ¼ãƒ¬ã‚¤ã‚’ç¢ºå®Ÿã«éè¡¨ç¤ºï¼ˆå‰Šé™¤ã™ã‚‹æ–¹ãŒç¢ºå®Ÿï¼‰
                const gameOverElement = document.getElementById('game-over-overlay');
                if (gameOverElement) {
                    gameOverElement.remove();
                }
                
                // èƒŒæ™¯ã¨ã‚°ãƒªãƒƒãƒ‰ã‚’æç”»ï¼ˆã‚¯ãƒªã‚¢çŠ¶æ…‹ï¼‰
                drawBackground();
                
                // ã‚«ã‚¦ãƒ³ãƒˆãƒ€ã‚¦ãƒ³è¦ç´ ã‚’å†ä½œæˆ
                const existingCountdown = document.getElementById('countdown');
                if (existingCountdown) {
                    existingCountdown.remove();
                }
                const canvasRect = canvas.getBoundingClientRect();
                const canvasCenterX = canvasRect.left + canvasRect.width / 2;
                const canvasCenterY = canvasRect.top + canvasRect.height / 2;
                countdownElement.style.cssText = `position:fixed;top:${canvasCenterY}px;left:${canvasCenterX}px;transform:translate(-50%,-50%);font-size:120px;font-weight:bold;color:#0969da;z-index:10001;pointer-events:none;text-shadow:2px 2px 4px rgba(0,0,0,0.5);`;
                document.body.appendChild(countdownElement);
                
                // ã‚«ã‚¦ãƒ³ãƒˆãƒ€ã‚¦ãƒ³é–‹å§‹
                showCountdown();
            }
            
            // ã‚²ãƒ¼ãƒ ãƒ«ãƒ¼ãƒ—
            let animationFrameId = null;
            function gameLoop() {
                const currentTime = performance.now();
                const deltaTime = currentTime - lastTime;
                lastTime = currentTime;
                
                // ã‚²ãƒ¼ãƒ æ›´æ–°
                update(deltaTime);
                
                // æç”»
                drawBackground();
                drawBlocks();
                drawGameOver();
                
                animationFrameId = requestAnimationFrame(gameLoop);
            }
            
            // ã‚²ãƒ¼ãƒ ãƒ«ãƒ¼ãƒ—ã‚’åœæ­¢
            function stopGameLoop() {
                if (animationFrameId !== null) {
                    cancelAnimationFrame(animationFrameId);
                    animationFrameId = null;
                }
            }
            
            // ã‚«ã‚¦ãƒ³ãƒˆãƒ€ã‚¦ãƒ³é–‹å§‹
            showCountdown();
        }
    </script>
</body>
</html>
