<!DOCTYPE html>
<html lang="ja">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>TETRIS</title>
    <link rel="stylesheet" href="styles/main.css">
</head>
<body>
    <!-- タイトル画面 -->
    <div id="title-screen" class="title-screen">
        <canvas id="title-canvas"></canvas>
        <div class="title-content">
            <h1 class="title-main">TETRIS</h1>
            <p class="title-subtitle">Press ENTER to Start</p>
        </div>
    </div>
    
    <!-- ゲーム画面 -->
    <div id="game-screen" class="game-screen hidden">
        <div class="container">
            <header class="header">
                <h1 class="title">TETRIS</h1>
            </header>
            
            <main class="game-container">
                <div class="game-panel">
                    <div class="left-panel">
                        <div class="panel-section hold-section">
                            <h2 class="panel-title">Hold</h2>
                            <canvas id="hold-canvas" width="120" height="120"></canvas>
                        </div>
                        <div class="panel-section controls-section">
                            <h2 class="panel-title">Controls</h2>
                            <div class="controls-list">
                                <div class="control-item">
                                    <span class="control-key"><span style="font-size: 1em;">←</span> <span style="font-size: 1em;">→</span></span>
                                    <span class="control-desc">Move Left/Right</span>
                                </div>
                                <div class="control-item">
                                    <span class="control-key">↓</span>
                                    <span class="control-desc">Soft Drop</span>
                                </div>
                                <div class="control-item">
                                    <span class="control-key">Z</span>
                                    <span class="control-desc">Rotate Left</span>
                                </div>
                                <div class="control-item">
                                    <span class="control-key">X</span>
                                    <span class="control-desc">Rotate Right</span>
                                </div>
                                <div class="control-item">
                                    <span class="control-key">C</span>
                                    <span class="control-desc">Hold</span>
                                </div>
                                <div class="control-item">
                                    <span class="control-key">Space</span>
                                    <span class="control-desc">Hard Drop</span>
                                </div>
                            </div>
                        </div>
                    </div>
                    <div class="panel-section board-section">
                        <div class="score-panel">
                            <div class="score-item">
                                <span class="score-label">Score</span>
                                <span id="score-value" class="score-value">0</span>
                            </div>
                            <div class="score-item">
                                <span class="score-label">Level</span>
                                <span id="level-value" class="score-value">1</span>
                            </div>
                            <div class="score-item">
                                <span class="score-label">Lines</span>
                                <span id="lines-value" class="score-value">0</span>
                            </div>
                        </div>
                        <canvas id="game-canvas" width="400" height="800"></canvas>
                    </div>
                    <div class="panel-section next-section">
                        <h2 class="panel-title">Next</h2>
                        <canvas id="next-canvas" width="120" height="600"></canvas>
                    </div>
                </div>
            </main>
        </div>
    </div>
    
    <script>
        // タイトル画面とゲーム画面の要素を取得
        const titleScreen = document.getElementById('title-screen');
        const gameScreen = document.getElementById('game-screen');
        let gameStarted = false;
        
        // タイトル画面のアニメーション
        function initTitleAnimation() {
            const titleCanvas = document.getElementById('title-canvas');
            titleCanvas.width = window.innerWidth;
            titleCanvas.height = window.innerHeight;
            const titleCtx = titleCanvas.getContext('2d');
            
            // テトリミノの種類と色（ゲームと同じ）
            const PIECE_TYPES = ['I', 'O', 'T', 'S', 'Z', 'J', 'L'];
            const PIECE_COLORS = {
                'I': '#00FFFF',  // シアン（公式標準色）
                'O': '#FFFF00',  // 黄色（公式標準色）
                'T': '#FF00FF',  // 紫（マゼンタ、公式標準色）
                'S': '#00FF00',  // 緑（公式標準色）
                'Z': '#FF0000',  // 赤（公式標準色）
                'J': '#FFA500',  // オレンジ（公式標準色）- Jはオレンジ
                'L': '#0000FF'   // 青（公式標準色）- Lは青
            };
            const PIECE_SHAPES = {
                'I': [{x: -1, y: 0}, {x: 0, y: 0}, {x: 1, y: 0}, {x: 2, y: 0}],
                'O': [{x: 0, y: 0}, {x: 1, y: 0}, {x: 0, y: 1}, {x: 1, y: 1}],
                'T': [{x: -1, y: 0}, {x: 0, y: 0}, {x: 1, y: 0}, {x: 0, y: 1}],
                'S': [{x: -1, y: 1}, {x: 0, y: 1}, {x: 0, y: 0}, {x: 1, y: 0}],
                'Z': [{x: -1, y: 0}, {x: 0, y: 0}, {x: 0, y: 1}, {x: 1, y: 1}],
                'J': [{x: -1, y: 0}, {x: 0, y: 0}, {x: 1, y: 0}, {x: -1, y: 1}],
                'L': [{x: -1, y: 0}, {x: 0, y: 0}, {x: 1, y: 0}, {x: 1, y: 1}]
            };
            
            const CELL_SIZE = 30;
            const blocks = [];
            let lastSpawnTime = 0;
            const SPAWN_INTERVAL = 250; // 新しいブロックを生成する間隔（ミリ秒）- 3倍の頻度
            
            // 初期ブロックを生成
            function createBlock() {
                const type = PIECE_TYPES[Math.floor(Math.random() * PIECE_TYPES.length)];
                const shape = PIECE_SHAPES[type];
                const minX = Math.min(...shape.map(p => p.x));
                const maxX = Math.max(...shape.map(p => p.x));
                const width = maxX - minX + 1;
                const maxWidth = Math.max(1, titleCanvas.width / CELL_SIZE - width);
                const startX = Math.random() * maxWidth + width / 2;
                
                return {
                    type: type,
                    x: startX,
                    y: -Math.max(...shape.map(p => p.y)) - 1,
                    shape: shape,
                    speed: 0.3 + Math.random() * 0.5,
                    rotation: Math.random() * Math.PI * 2,
                    rotationSpeed: (Math.random() - 0.5) * 0.02
                };
            }
            
            // 初期ブロックを生成（画面全体に分散）
            for (let i = 0; i < 30; i++) {
                const block = createBlock();
                block.y = -Math.random() * titleCanvas.height * 2 - 50; // 画面外のランダムな位置
                blocks.push(block);
            }
            
            // ブロックを描画
            function drawBlock(block) {
                titleCtx.save();
                titleCtx.translate(block.x * CELL_SIZE, block.y * CELL_SIZE);
                titleCtx.rotate(block.rotation);
                
                const color = PIECE_COLORS[block.type];
                block.shape.forEach(cell => {
                    const x = cell.x * CELL_SIZE;
                    const y = cell.y * CELL_SIZE;
                    
                    // グラデーション効果
                    const gradient = titleCtx.createRadialGradient(x + CELL_SIZE/2, y + CELL_SIZE/2, 0, x + CELL_SIZE/2, y + CELL_SIZE/2, CELL_SIZE);
                    gradient.addColorStop(0, color);
                    gradient.addColorStop(1, color + '80');
                    
                    titleCtx.fillStyle = gradient;
                    titleCtx.fillRect(x + 2, y + 2, CELL_SIZE - 4, CELL_SIZE - 4);
                    
                    // 光沢効果
                    titleCtx.strokeStyle = 'rgba(255, 255, 255, 0.3)';
                    titleCtx.lineWidth = 2;
                    titleCtx.strokeRect(x + 2, y + 2, CELL_SIZE - 4, CELL_SIZE - 4);
                });
                
                titleCtx.restore();
            }
            
            // アニメーションループ
            function animate(currentTime) {
                if (titleScreen.classList.contains('hidden')) {
                    return; // タイトル画面が非表示の場合は停止
                }
                
                // 背景をクリア（半透明にして残像効果）
                titleCtx.fillStyle = 'rgba(13, 17, 23, 0.15)';
                titleCtx.fillRect(0, 0, titleCanvas.width, titleCanvas.height);
                
                // 定期的に新しいブロックを生成（複数同時に生成）
                if (currentTime - lastSpawnTime > SPAWN_INTERVAL) {
                    // 一度に2〜3個のブロックを生成
                    const spawnCount = Math.floor(Math.random() * 2) + 2; // 2個または3個
                    for (let i = 0; i < spawnCount; i++) {
                        const newBlock = createBlock();
                        newBlock.y = -Math.max(...newBlock.shape.map(p => p.y)) * CELL_SIZE - 20 - i * 30;
                        blocks.push(newBlock);
                    }
                    lastSpawnTime = currentTime;
                }
                
                // ブロックを更新・描画
                for (let i = blocks.length - 1; i >= 0; i--) {
                    const block = blocks[i];
                    block.y += block.speed;
                    block.rotation += block.rotationSpeed;
                    
                    // 画面下部に到達したら削除（新しいブロックが生成される）
                    const maxY = Math.max(...block.shape.map(p => p.y));
                    if (block.y + maxY * CELL_SIZE > titleCanvas.height + 100) {
                        blocks.splice(i, 1);
                        continue;
                    }
                    
                    drawBlock(block);
                }
                
                requestAnimationFrame(animate);
            }
            
            // リサイズ時の処理
            window.addEventListener('resize', () => {
                titleCanvas.width = window.innerWidth;
                titleCanvas.height = window.innerHeight;
            });
            
            animate(performance.now());
        }
        
        // タイトル画面のアニメーションを初期化
        initTitleAnimation();
        
        // Enterキーでゲーム開始
        document.addEventListener('keydown', (e) => {
            if (e.key === 'Enter' && !gameStarted) {
                console.log('Enter key pressed - starting game');
                titleScreen.classList.add('hidden');
                gameScreen.classList.remove('hidden');
                gameStarted = true;
                startGame();
            }
        });
        
        // ゲーム開始
        function startGame() {
            const canvas = document.getElementById('game-canvas');
            const ctx = canvas.getContext('2d');
            const nextCanvas = document.getElementById('next-canvas');
            const nextCtx = nextCanvas.getContext('2d');
            const holdCanvas = document.getElementById('hold-canvas');
            const holdCtx = holdCanvas.getContext('2d');
            
            const CELL_SIZE = 40;
            const NEXT_CELL_SIZE = 20; // Nextブロック表示用のセルサイズ
            const HOLD_CELL_SIZE = 25; // Holdブロック表示用のセルサイズ
            const BOARD_WIDTH = 10;
            const BOARD_HEIGHT = 20;
            const BG_COLOR = '#2d3136'; // 背景色
            const DROP_INTERVAL = 500; // 落下間隔（ミリ秒）
            
            // テトリミノの種類と色
            const PIECE_TYPES = ['I', 'O', 'T', 'S', 'Z', 'J', 'L'];
            const PIECE_COLORS = {
                'I': '#00FFFF',  // シアン（公式標準色）
                'O': '#FFFF00',  // 黄色（公式標準色）
                'T': '#FF00FF',  // 紫（マゼンタ、公式標準色）
                'S': '#00FF00',  // 緑（公式標準色）
                'Z': '#FF0000',  // 赤（公式標準色）
                'J': '#FFA500',  // オレンジ（公式標準色）- Jはオレンジ
                'L': '#0000FF'   // 青（公式標準色）- Lは青
            };
            
            // テトリミノの形状（相対座標、中心を(0,0)とした相対位置）
            const PIECE_SHAPES = {
                'I': [{x: -1, y: 0}, {x: 0, y: 0}, {x: 1, y: 0}, {x: 2, y: 0}],
                'O': [{x: 0, y: 0}, {x: 1, y: 0}, {x: 0, y: 1}, {x: 1, y: 1}],
                'T': [{x: -1, y: 0}, {x: 0, y: 0}, {x: 1, y: 0}, {x: 0, y: 1}],
                'S': [{x: -1, y: 1}, {x: 0, y: 1}, {x: 0, y: 0}, {x: 1, y: 0}],
                'Z': [{x: -1, y: 0}, {x: 0, y: 0}, {x: 0, y: 1}, {x: 1, y: 1}],
                'J': [{x: -1, y: 0}, {x: 0, y: 0}, {x: 1, y: 0}, {x: -1, y: 1}],
                'L': [{x: -1, y: 0}, {x: 0, y: 0}, {x: 1, y: 0}, {x: 1, y: 1}]
            };
            
            console.log('Canvas initialized');
            console.log('Canvas size:', canvas.width, 'x', canvas.height);
            
            // ゲーム状態
            let currentBlock = null; // 現在のブロック {type, x, y, shape}
            let placedBlocks = []; // 落下したブロックの配列 [{type, x, y, shape}, ...]
            let nextBlocks = []; // 次の5つのブロック [{type, shape}, ...]
            let holdBlock = null; // ホールド中のブロック {type, shape}
            let canHold = true; // ホールド可能かどうか（1回のピースにつき1回のみ）
            let dropTimer = 0;
            let lastTime = performance.now();
            let gameActive = false;
            let gameOver = false; // ゲームオーバー状態
            let showRetryMessage = false; // リトライメッセージを表示するか
            window.currentDropInterval = DROP_INTERVAL_BASE; // 現在の落下間隔
            
            // スコア、レベル、ライン数
            let score = 0;
            let level = 1;
            let lines = 0;
            const DROP_INTERVAL_BASE = 500; // 基本落下間隔（ミリ秒）
            
            // スコア・レベル・ライン数の表示を更新
            function updateScoreDisplay() {
                document.getElementById('score-value').textContent = score.toLocaleString();
                document.getElementById('level-value').textContent = level;
                document.getElementById('lines-value').textContent = lines;
            }
            
            // スコア計算（ライン消去時）
            function calculateScore(linesCleared) {
                // テトリスの標準スコア計算
                // 1行: 100 * level
                // 2行: 300 * level
                // 3行: 500 * level
                // 4行（Tetris）: 800 * level
                const baseScores = [0, 100, 300, 500, 800];
                const baseScore = baseScores[linesCleared] || 0;
                
                // コンボボーナス（連続でラインを消去した場合）
                let comboBonus = 0;
                if (combo > 0) {
                    comboBonus = combo * 50 * level;
                }
                
                return (baseScore * level) + comboBonus;
            }
            
            // レベル計算（ライン数に基づく）
            function updateLevel() {
                const newLevel = Math.floor(lines / 10) + 1;
                if (newLevel !== level) {
                    level = newLevel;
                    // レベルが上がると落下速度が速くなる
                    // レベル1: 500ms, レベル2: 450ms, ... レベル10: 50ms
                    const newDropInterval = Math.max(50, DROP_INTERVAL_BASE - (level - 1) * 50);
                    // グローバル変数として保持（update関数で使用）
                    window.currentDropInterval = newDropInterval;
                }
            }
            let showGrid = true; // グリッド表示フラグ
            
            // カウントダウン表示
            let countdown = 3;
            
            // カウントダウン要素を作成（Canvasの中心に配置）
            const countdownElement = document.createElement('div');
            countdownElement.id = 'countdown';
            // Canvasの位置を取得して中央に配置
            const canvasRect = canvas.getBoundingClientRect();
            const canvasCenterX = canvasRect.left + canvasRect.width / 2;
            const canvasCenterY = canvasRect.top + canvasRect.height / 2;
            countdownElement.style.cssText = `position:fixed;top:${canvasCenterY}px;left:${canvasCenterX}px;transform:translate(-50%,-50%);font-size:120px;font-weight:bold;color:#0969da;z-index:10001;pointer-events:none;text-shadow:2px 2px 4px rgba(0,0,0,0.5);`;
            document.body.appendChild(countdownElement);
            
            // カウントダウン処理（2倍速）
            function showCountdown() {
                // カウントダウン中も背景とグリッドを描画
                drawBackground();
                
                // ゲームオーバーオーバーレイが残っていないか確認して削除
                const gameOverElement = document.getElementById('game-over-overlay');
                if (gameOverElement) {
                    gameOverElement.remove();
                }
                
                if (countdown > 0) {
                    countdownElement.textContent = countdown.toString();
                    countdown--;
                    setTimeout(showCountdown, 500); // 1秒から0.5秒に変更（2倍速）
                } else {
                    countdownElement.textContent = 'START!';
                    setTimeout(() => {
                        countdownElement.remove();
                        // 念のためゲームオーバーオーバーレイを再度確認して削除
                        const gameOverElement2 = document.getElementById('game-over-overlay');
                        if (gameOverElement2) {
                            gameOverElement2.remove();
                        }
                        gameActive = true;
                        // 次のブロックを準備
                        prepareNextBlocks();
                        // 最初のブロックを生成
                        spawnBlock();
                        // Holdブロックを描画（初期状態は空）
                        drawHoldBlock();
                        // ゲームループ開始
                        gameLoop();
                    }, 250); // 0.5秒から0.25秒に変更（2倍速）
                }
            }
            
            // ランダムにブロックタイプを選ぶ
            // 7-Bag System: 7種類のテトリミノを1セットとしてシャッフルして提供
            let pieceBag = [];
            
            // Fisher-Yatesアルゴリズムでシャッフル
            function shuffleArray(array) {
                const shuffled = [...array];
                for (let i = shuffled.length - 1; i > 0; i--) {
                    const j = Math.floor(Math.random() * (i + 1));
                    [shuffled[i], shuffled[j]] = [shuffled[j], shuffled[i]];
                }
                return shuffled;
            }
            
            // 新しいバッグを生成（7種類のテトリミノをシャッフル）
            function generateNewBag() {
                pieceBag = shuffleArray([...PIECE_TYPES]);
            }
            
            // バッグから次のテトリミノを取得
            function getNextPieceFromBag() {
                // バッグが空の場合は新しいバッグを生成
                if (pieceBag.length === 0) {
                    generateNewBag();
                }
                // バッグの最初の要素を取得して削除
                return pieceBag.shift();
            }
            
            // 次のブロックを準備（5つ）- 7-Bag Systemを使用
            function prepareNextBlocks() {
                nextBlocks = [];
                for (let i = 0; i < 5; i++) {
                    const type = getNextPieceFromBag();
                    nextBlocks.push({
                        type: type,
                        shape: PIECE_SHAPES[type]
                    });
                }
            }
            
            // ブロックを生成（画面外から）
            function spawnBlock() {
                // 次のブロックがなければ準備
                if (nextBlocks.length === 0) {
                    prepareNextBlocks();
                }
                
                // 最初のブロックを取得
                const nextBlock = nextBlocks.shift();
                const type = nextBlock.type;
                const shape = [...nextBlock.shape]; // コピーを作成
                
                // 次のブロックを1つ追加（常に5つ保持）- 7-Bag Systemを使用
                const newType = getNextPieceFromBag();
                nextBlocks.push({
                    type: newType,
                    shape: PIECE_SHAPES[newType]
                });
                
                // ブロックの幅を計算して中央に配置
                const minX = Math.min(...shape.map(p => p.x));
                const maxX = Math.max(...shape.map(p => p.x));
                const width = maxX - minX + 1;
                const startX = Math.floor((BOARD_WIDTH - width) / 2) - minX;
                
                // ブロックの形状の最大y座標を計算
                const maxY = Math.max(...shape.map(p => p.y));
                
                // ブロック全体が画面外（y < 0）になるように初期位置を設定
                // ブロックの最下部がy=-1になるように、初期yを-1 - maxYに設定
                const startY = -1 - maxY;
                
                currentBlock = {
                    type: type,
                    x: startX,
                    y: startY,  // 画面外から
                    shape: shape
                };
                canHold = true; // ホールドを再度可能にする
                console.log('Block spawned:', type, 'at:', currentBlock.x, currentBlock.y);
                
                // Nextブロック表示を更新
                drawNextBlocks();
            }
            
            // ホールド機能
            function holdCurrentBlock() {
                if (!currentBlock || !canHold) return;
                
                if (holdBlock === null) {
                    // ホールドが空の場合、現在のブロックをホールド
                    holdBlock = {
                        type: currentBlock.type,
                        shape: [...currentBlock.shape]
                    };
                    // 次のブロックを生成
                    spawnBlock();
                } else {
                    // ホールドにブロックがある場合、交換
                    const temp = holdBlock;
                    holdBlock = {
                        type: currentBlock.type,
                        shape: [...currentBlock.shape]
                    };
                    
                    // ホールドしていたブロックを現在のブロックとして生成
                    const type = temp.type;
                    const shape = [...temp.shape];
                    const minX = Math.min(...shape.map(p => p.x));
                    const maxX = Math.max(...shape.map(p => p.x));
                    const width = maxX - minX + 1;
                    const startX = Math.floor((BOARD_WIDTH - width) / 2) - minX;
                    
                    // ブロックの形状の最大y座標を計算
                    const maxY = Math.max(...shape.map(p => p.y));
                    // ブロック全体が画面外（y < 0）になるように初期位置を設定
                    const startY = -1 - maxY;
                    
                    currentBlock = {
                        type: type,
                        x: startX,
                        y: startY,
                        shape: shape
                    };
                }
                
                canHold = false; // 1回のピースにつき1回のみホールド可能
                drawHoldBlock();
            }
            
            // ブロックが一番下に到達したかチェック
            function isBlockAtBottom() {
                if (!currentBlock) return false;
                // ブロックの形状に応じて最下部をチェック
                const maxY = Math.max(...currentBlock.shape.map(p => p.y));
                return currentBlock.y + maxY >= BOARD_HEIGHT - 1;
            }
            
            // ゴーストピースの位置を計算（落下予測位置）
            function getGhostPosition() {
                if (!currentBlock) return null;
                
                let ghostY = currentBlock.y;
                // 下に移動できる限り移動
                while (!hasCollision(currentBlock.x, ghostY + 1, currentBlock.shape)) {
                    const maxY = Math.max(...currentBlock.shape.map(p => p.y));
                    // 画面内の最下部に到達したら停止
                    if (ghostY + maxY >= BOARD_HEIGHT - 1) break;
                    ghostY += 1;
                }
                
                return { x: currentBlock.x, y: ghostY };
            }
            
            // 完全に埋まっている行を検出
            function getFullRows() {
                // 各行にブロックがあるかチェック
                const rowCells = Array(BOARD_HEIGHT).fill(null).map(() => Array(BOARD_WIDTH).fill(false));
                
                // 配置済みブロックの各セルをマーク
                placedBlocks.forEach(block => {
                    block.shape.forEach(cell => {
                        const x = block.x + cell.x;
                        const y = block.y + cell.y;
                        if (x >= 0 && x < BOARD_WIDTH && y >= 0 && y < BOARD_HEIGHT) {
                            rowCells[y][x] = true;
                        }
                    });
                });
                
                // 完全に埋まっている行を検出
                const fullRows = [];
                for (let y = 0; y < BOARD_HEIGHT; y++) {
                    if (rowCells[y].every(cell => cell === true)) {
                        fullRows.push(y);
                    }
                }
                
                return fullRows;
            }
            
            // ゲームオーバー判定（真ん中4列の画面上部にブロックが積まれた場合）
            function checkGameOver() {
                // 真ん中4列は列2, 3, 4, 5（インデックス2, 3, 4, 5）
                const centerColumns = [2, 3, 4, 5];
                
                // 配置済みブロックをチェック
                for (const block of placedBlocks) {
                    for (const cell of block.shape) {
                        const x = block.x + cell.x;
                        const y = block.y + cell.y;
                        
                        // 真ん中4列の画面上部（y < 0）にブロックがあるかチェック
                        if (centerColumns.includes(x) && y < 0) {
                            return true;
                        }
                    }
                }
                
                // 現在落下中のブロックもチェック
                if (currentBlock) {
                    for (const cell of currentBlock.shape) {
                        const x = currentBlock.x + cell.x;
                        const y = currentBlock.y + cell.y;
                        
                        // 真ん中4列の画面上部（y < 0）にブロックがあるかチェック
                        if (centerColumns.includes(x) && y < 0) {
                            return true;
                        }
                    }
                }
                
                return false;
            }
            
            // 完全に埋まっている行を消去し、上のブロックを下に落とす
            function clearFullRows() {
                const fullRows = getFullRows();
                if (fullRows.length === 0) return;
                
                console.log('Clearing full rows:', fullRows);
                
                // 消去する行をセットとして保持（高速検索のため）
                const fullRowsSet = new Set(fullRows);
                
                // すべてのブロックから消去する行のセルを一度に削除
                placedBlocks = placedBlocks.map(block => {
                    // 消去する行に含まれるセルを除外
                    const filteredShape = block.shape.filter(cell => {
                        const y = block.y + cell.y;
                        return !fullRowsSet.has(y);
                    });
                    
                    // セルが残っている場合のみブロックを保持
                    if (filteredShape.length > 0) {
                        return {
                            ...block,
                            shape: filteredShape
                        };
                    }
                    return null;
                }).filter(block => block !== null);
                
                // 消去した行より上にあるブロックを、消去した行数分だけ下に落とす
                // 下から上に処理することで、複数行消去時も正しく動作
                fullRows.sort((a, b) => b - a); // 下から上にソート
                
                placedBlocks.forEach(block => {
                    // ブロックの最小y座標を計算
                    if (block.shape.length > 0) {
                        const minY = Math.min(...block.shape.map(cell => block.y + cell.y));
                        // 消去した行より上にあるブロックを、消去した行数分だけ下に移動
                        let dropCount = 0;
                        for (const clearedRow of fullRows) {
                            if (minY < clearedRow) {
                                dropCount++;
                            }
                        }
                        if (dropCount > 0) {
                            block.y += dropCount;
                        }
                    }
                });
                
                // スコアとライン数を更新
                const linesCleared = fullRows.length;
                const currentTime = performance.now();
                
                // コンボ判定（2秒以内に連続でラインを消去した場合）
                if (currentTime - lastClearTime < COMBO_TIMEOUT && lastClearTime > 0) {
                    combo++;
                } else {
                    combo = 0; // コンボリセット
                }
                lastClearTime = currentTime;
                
                lines += linesCleared;
                score += calculateScore(linesCleared);
                updateLevel();
                updateScoreDisplay();
                
                // テトリス（4ライン同時消去）の特別表示
                if (linesCleared === 4) {
                    console.log('TETRIS!');
                    // 将来的にエフェクトを追加可能
                }
                
                console.log('Rows cleared:', linesCleared, 'Combo:', combo, 'Total lines:', lines, 'Score:', score, 'Level:', level);
            }
            
            // ブロックを回転させる（時計回り90度）
            function rotateClockwise(shape) {
                return shape.map(cell => ({ x: -cell.y, y: cell.x }));
            }
            
            // ブロックを回転させる（反時計回り90度）
            function rotateCounterClockwise(shape) {
                return shape.map(cell => ({ x: cell.y, y: -cell.x }));
            }
            
            // ブロックが他のブロックと衝突しているかチェック
            function hasCollision(newX, newY, shape) {
                if (!shape) shape = currentBlock.shape;
                
                // ブロックの各セルをチェック
                for (const cell of shape) {
                    const checkX = newX + cell.x;
                    const checkY = newY + cell.y;
                    
                    // 壁との衝突チェック（横方向のみ）
                    if (checkX < 0 || checkX >= BOARD_WIDTH) {
                        return true;
                    }
                    
                    // 画面内のセルのみ衝突チェック
                    if (checkY >= 0 && checkY < BOARD_HEIGHT) {
                        // 配置済みブロックとの衝突チェック
                        for (const placedBlock of placedBlocks) {
                            for (const placedCell of placedBlock.shape) {
                                const placedX = placedBlock.x + placedCell.x;
                                const placedY = placedBlock.y + placedCell.y;
                                // 画面内の配置済みブロックとのみ衝突チェック
                                if (placedY >= 0 && placedX === checkX && placedY === checkY) {
                                    return true;
                                }
                            }
                        }
                    }
                }
                return false;
            }
            
            // キー入力処理
            document.addEventListener('keydown', (e) => {
                // ゲームオーバー時のEnterキー処理
                if (gameOver && e.key === 'Enter') {
                    e.preventDefault();
                    resetGame();
                    return;
                }
                
                if (!gameActive || !currentBlock || gameOver) return;
                
                switch(e.key) {
                    case 'ArrowLeft':
                        // 左に移動
                        e.preventDefault();
                        if (!hasCollision(currentBlock.x - 1, currentBlock.y, currentBlock.shape)) {
                            currentBlock.x -= 1;
                        }
                        break;
                    case 'ArrowRight':
                        // 右に移動
                        e.preventDefault();
                        if (!hasCollision(currentBlock.x + 1, currentBlock.y, currentBlock.shape)) {
                            currentBlock.x += 1;
                        }
                        break;
                    case 'ArrowDown':
                        // ソフトドロップ（下に移動）
                        e.preventDefault(); // スクロールを防ぐ
                        if (!hasCollision(currentBlock.x, currentBlock.y + 1, currentBlock.shape)) {
                            currentBlock.y += 1;
                            dropTimer = 0; // タイマーリセット
                        }
                        break;
                    case 'z':
                    case 'Z':
                        // 左回転（反時計回り）
                        e.preventDefault();
                        const rotatedLeft = rotateCounterClockwise(currentBlock.shape);
                        if (!hasCollision(currentBlock.x, currentBlock.y, rotatedLeft)) {
                            currentBlock.shape = rotatedLeft;
                        }
                        break;
                    case 'x':
                    case 'X':
                        // 右回転（時計回り）
                        e.preventDefault();
                        const rotatedRight = rotateClockwise(currentBlock.shape);
                        if (!hasCollision(currentBlock.x, currentBlock.y, rotatedRight)) {
                            currentBlock.shape = rotatedRight;
                        }
                        break;
                    case 'c':
                    case 'C':
                        // ホールド
                        e.preventDefault();
                        holdCurrentBlock();
                        break;
                    case 'g':
                    case 'G':
                        // グリッド表示のトグル
                        e.preventDefault();
                        showGrid = !showGrid;
                        break;
                    case 'p':
                    case 'P':
                        // ポーズ/再開
                        e.preventDefault();
                        if (gameActive && !gameOver) {
                            gameActive = !gameActive;
                            if (gameActive) {
                                lastTime = performance.now();
                                gameLoop();
                            }
                        }
                        break;
                    case 'r':
                    case 'R':
                        // リスタート
                        e.preventDefault();
                        if (gameOver || !gameActive) {
                            resetGame();
                        }
                        break;
                    case ' ':
                    case 'Space':
                        // ハードドロップ（一気に下に落とす）
                        e.preventDefault();
                        let dropY = currentBlock.y;
                        while (!hasCollision(currentBlock.x, dropY + 1, currentBlock.shape)) {
                            const maxY = Math.max(...currentBlock.shape.map(p => p.y));
                            if (dropY + maxY >= BOARD_HEIGHT - 1) break;
                            dropY += 1;
                        }
                        currentBlock.y = dropY;
                        // 即座に固定（画面内のセルのみ保存）
                        const placedShape = currentBlock.shape.filter(cell => {
                            const y = currentBlock.y + cell.y;
                            return y >= 0 && y < BOARD_HEIGHT;
                        });
                        if (placedShape.length > 0) {
                            placedBlocks.push({
                                type: currentBlock.type,
                                x: currentBlock.x,
                                y: currentBlock.y,
                                shape: placedShape
                            });
                        }
                        // 完全に埋まっている行を消去
                        clearFullRows();
                        spawnBlock();
                        break;
                }
            });
            
            // 背景を描画
            function drawBackground() {
                // 背景色で塗りつぶし
                ctx.fillStyle = BG_COLOR;
                ctx.fillRect(0, 0, canvas.width, canvas.height);
                
                // グリッド線を描画（showGridフラグがtrueの場合のみ）
                if (showGrid) {
                    ctx.strokeStyle = 'rgba(139, 148, 158, 0.3)'; // 薄いグリッド色
                    ctx.lineWidth = 1;
                    
                    // 縦線を描画
                    for (let x = 0; x <= BOARD_WIDTH; x++) {
                        ctx.beginPath();
                        ctx.moveTo(x * CELL_SIZE, 0);
                        ctx.lineTo(x * CELL_SIZE, canvas.height);
                        ctx.stroke();
                    }
                    
                    // 横線を描画
                    for (let y = 0; y <= BOARD_HEIGHT; y++) {
                        ctx.beginPath();
                        ctx.moveTo(0, y * CELL_SIZE);
                        ctx.lineTo(canvas.width, y * CELL_SIZE);
                        ctx.stroke();
                    }
                }
            }
            
            // ブロックを描画
            function drawBlock(blockX, blockY, shape, color, isGhost = false) {
                // ブロックの各セルを描画（画面内のセルのみ）
                for (const cell of shape) {
                    const cellY = blockY + cell.y;
                    // 画面内のセルのみ描画
                    if (cellY < 0 || cellY >= BOARD_HEIGHT) continue;
                    
                    const x = (blockX + cell.x) * CELL_SIZE;
                    const y = cellY * CELL_SIZE;
                    
                    if (isGhost) {
                        // ゴーストピースは薄く表示（アウトラインのみ）
                        ctx.strokeStyle = color;
                        ctx.lineWidth = 2;
                        ctx.setLineDash([4, 4]); // 点線
                        ctx.strokeRect(x + 2, y + 2, CELL_SIZE - 4, CELL_SIZE - 4);
                        ctx.setLineDash([]); // 点線をリセット
                    } else {
                        // 通常のブロック
                        // 色で塗りつぶし
                        ctx.fillStyle = color;
                        ctx.fillRect(x + 2, y + 2, CELL_SIZE - 4, CELL_SIZE - 4);
                        
                        // 白いアウトライン
                        ctx.strokeStyle = '#ffffff';
                        ctx.lineWidth = 2;
                        ctx.strokeRect(x + 2, y + 2, CELL_SIZE - 4, CELL_SIZE - 4);
                    }
                }
            }
            
            // Holdブロックを描画
            function drawHoldBlock() {
                // 背景をクリア
                holdCtx.fillStyle = BG_COLOR;
                holdCtx.fillRect(0, 0, holdCanvas.width, holdCanvas.height);
                
                if (holdBlock) {
                    const color = PIECE_COLORS[holdBlock.type];
                    
                    // ブロックの中心を計算
                    const minX = Math.min(...holdBlock.shape.map(p => p.x));
                    const maxX = Math.max(...holdBlock.shape.map(p => p.x));
                    const minY = Math.min(...holdBlock.shape.map(p => p.y));
                    const maxY = Math.max(...holdBlock.shape.map(p => p.y));
                    const blockWidth = (maxX - minX + 1) * HOLD_CELL_SIZE;
                    const blockHeight = (maxY - minY + 1) * HOLD_CELL_SIZE;
                    const centerX = (holdCanvas.width - blockWidth) / 2;
                    const centerY = (holdCanvas.height - blockHeight) / 2;
                    
                    // ブロックの各セルを描画
                    holdBlock.shape.forEach(cell => {
                        const x = centerX + (cell.x - minX) * HOLD_CELL_SIZE;
                        const y = centerY + (cell.y - minY) * HOLD_CELL_SIZE;
                        
                        // 色で塗りつぶし
                        holdCtx.fillStyle = color;
                        holdCtx.fillRect(x + 1, y + 1, HOLD_CELL_SIZE - 2, HOLD_CELL_SIZE - 2);
                        
                        // 白いアウトライン
                        holdCtx.strokeStyle = '#ffffff';
                        holdCtx.lineWidth = 1;
                        holdCtx.strokeRect(x + 1, y + 1, HOLD_CELL_SIZE - 2, HOLD_CELL_SIZE - 2);
                    });
                }
            }
            
            // Nextブロックを描画
            function drawNextBlocks() {
                // 背景をクリア
                nextCtx.fillStyle = BG_COLOR;
                nextCtx.fillRect(0, 0, nextCanvas.width, nextCanvas.height);
                
                // 各Nextブロックを描画（最大5つ）
                const blockHeight = 100; // 各ブロックの高さ
                const startY = 20; // 開始位置
                
                nextBlocks.slice(0, 5).forEach((block, index) => {
                    const y = startY + index * blockHeight;
                    const color = PIECE_COLORS[block.type];
                    
                    // ブロックの中心を計算
                    const minX = Math.min(...block.shape.map(p => p.x));
                    const maxX = Math.max(...block.shape.map(p => p.x));
                    const minY = Math.min(...block.shape.map(p => p.y));
                    const maxY = Math.max(...block.shape.map(p => p.y));
                    const blockWidth = (maxX - minX + 1) * NEXT_CELL_SIZE;
                    const blockHeight2 = (maxY - minY + 1) * NEXT_CELL_SIZE;
                    const centerX = (nextCanvas.width - blockWidth) / 2;
                    
                    // ブロックの各セルを描画
                    block.shape.forEach(cell => {
                        const x = centerX + (cell.x - minX) * NEXT_CELL_SIZE;
                        const cellY = y + (cell.y - minY) * NEXT_CELL_SIZE;
                        
                        // 色で塗りつぶし
                        nextCtx.fillStyle = color;
                        nextCtx.fillRect(x + 1, cellY + 1, NEXT_CELL_SIZE - 2, NEXT_CELL_SIZE - 2);
                        
                        // 白いアウトライン
                        nextCtx.strokeStyle = '#ffffff';
                        nextCtx.lineWidth = 1;
                        nextCtx.strokeRect(x + 1, cellY + 1, NEXT_CELL_SIZE - 2, NEXT_CELL_SIZE - 2);
                    });
                });
            }
            
            // ブロックを描画（現在のブロックと配置済みブロック）
            function drawBlocks() {
                // ゴーストピースを描画（現在のブロックの落下予測位置）
                if (currentBlock) {
                    const ghostPos = getGhostPosition();
                    if (ghostPos && ghostPos.y !== currentBlock.y) {
                        const ghostColor = PIECE_COLORS[currentBlock.type];
                        drawBlock(ghostPos.x, ghostPos.y, currentBlock.shape, ghostColor, true);
                    }
                }
                
                // 配置済みブロックを描画
                placedBlocks.forEach(block => {
                    const color = PIECE_COLORS[block.type];
                    drawBlock(block.x, block.y, block.shape, color);
                });
                
                // 現在のブロックを描画（最後に描画して前面に表示）
                if (currentBlock) {
                    const color = PIECE_COLORS[currentBlock.type];
                    drawBlock(currentBlock.x, currentBlock.y, currentBlock.shape, color);
                }
            }
            
            // ゲーム更新
            function update(deltaTime) {
                if (!gameActive || !currentBlock || gameOver) return;
                
                dropTimer += deltaTime;
                
                // 現在の落下間隔を使用（レベルに応じて変化）
                const currentDropInterval = window.currentDropInterval || DROP_INTERVAL_BASE;
                
                if (dropTimer >= currentDropInterval) {
                    dropTimer = 0;
                    
                    // ブロックを下に移動
                    if (isBlockAtBottom() || hasCollision(currentBlock.x, currentBlock.y + 1, currentBlock.shape)) {
                        // 一番下に到達したか、他のブロックと衝突したら、現在のブロックを配置済みブロックに追加
                        console.log('Block reached bottom or collision, placing block');
                        // 画面内のセルのみ保存
                        const placedShape = currentBlock.shape.filter(cell => {
                            const y = currentBlock.y + cell.y;
                            return y >= 0 && y < BOARD_HEIGHT;
                        });
                        if (placedShape.length > 0) {
                            placedBlocks.push({
                                type: currentBlock.type,
                                x: currentBlock.x,
                                y: currentBlock.y,
                                shape: placedShape
                            });
                        }
                        // 完全に埋まっている行を消去
                        clearFullRows();
                        
                        // ゲームオーバー判定
                        if (checkGameOver()) {
                            gameOver = true;
                            gameActive = false;
                            // 1秒後にリトライメッセージを表示
                            setTimeout(() => {
                                showRetryMessage = true;
                            }, 1000);
                            return;
                        }
                        
                        // 次のブロックを生成
                        spawnBlock();
                    } else {
                        // まだ下に移動できる
                        currentBlock.y += 1;
                    }
                }
            }
            
            // ゲームオーバー画面を描画
            function drawGameOver() {
                let gameOverElement = document.getElementById('game-over-overlay');
                
                if (!gameOver) {
                    // ゲームオーバー要素を非表示
                    if (gameOverElement) {
                        gameOverElement.classList.add('hidden');
                    }
                    return;
                }
                
                // ゲームオーバー要素を表示
                if (!gameOverElement) {
                    // ゲームオーバーオーバーレイを作成
                    gameOverElement = document.createElement('div');
                    gameOverElement.id = 'game-over-overlay';
                    gameOverElement.innerHTML = `
                        <div class="game-over-content">
                            <div id="game-over-text" class="game-over-text">Game Over</div>
                            <div id="retry-message" class="retry-message hidden">Press Enter To Retry</div>
                        </div>
                    `;
                    document.getElementById('game-screen').appendChild(gameOverElement);
                }
                
                gameOverElement.classList.remove('hidden');
                
                // リトライメッセージの表示/非表示
                const retryMessage = gameOverElement.querySelector('#retry-message');
                if (retryMessage) {
                    if (showRetryMessage) {
                        retryMessage.classList.remove('hidden');
                    } else {
                        retryMessage.classList.add('hidden');
                    }
                }
                
                // Canvas上にも暗いオーバーレイを描画
                ctx.fillStyle = 'rgba(0, 0, 0, 0.6)';
                ctx.fillRect(0, 0, canvas.width, canvas.height);
            }
            
            // ゲームリセット
            function resetGame() {
                // ゲームループを停止
                stopGameLoop();
                
                currentBlock = null;
                placedBlocks = [];
                nextBlocks = [];
                holdBlock = null;
                canHold = true;
                dropTimer = 0;
                lastTime = performance.now();
                gameActive = false;
                gameOver = false;
                showRetryMessage = false;
                countdown = 3;
                score = 0;
                level = 1;
                lines = 0;
                combo = 0;
                lastClearTime = 0;
                window.currentDropInterval = DROP_INTERVAL_BASE;
                updateScoreDisplay();
                
                // ゲームオーバーオーバーレイを確実に非表示（削除する方が確実）
                const gameOverElement = document.getElementById('game-over-overlay');
                if (gameOverElement) {
                    gameOverElement.remove();
                }
                
                // 背景とグリッドを描画（クリア状態）
                drawBackground();
                
                // カウントダウン要素を再作成
                const existingCountdown = document.getElementById('countdown');
                if (existingCountdown) {
                    existingCountdown.remove();
                }
                const canvasRect = canvas.getBoundingClientRect();
                const canvasCenterX = canvasRect.left + canvasRect.width / 2;
                const canvasCenterY = canvasRect.top + canvasRect.height / 2;
                countdownElement.style.cssText = `position:fixed;top:${canvasCenterY}px;left:${canvasCenterX}px;transform:translate(-50%,-50%);font-size:120px;font-weight:bold;color:#0969da;z-index:10001;pointer-events:none;text-shadow:2px 2px 4px rgba(0,0,0,0.5);`;
                document.body.appendChild(countdownElement);
                
                // カウントダウン開始
                showCountdown();
            }
            
            // ゲームループ
            let animationFrameId = null;
            function gameLoop() {
                const currentTime = performance.now();
                const deltaTime = currentTime - lastTime;
                lastTime = currentTime;
                
                // ゲーム更新
                update(deltaTime);
                
                // 描画
                drawBackground();
                drawBlocks();
                drawGameOver();
                
                animationFrameId = requestAnimationFrame(gameLoop);
            }
            
            // ゲームループを停止
            function stopGameLoop() {
                if (animationFrameId !== null) {
                    cancelAnimationFrame(animationFrameId);
                    animationFrameId = null;
                }
            }
            
            // カウントダウン開始
            showCountdown();
        }
    </script>
</body>
</html>
